<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LinkedHashMap</title>
    <url>/2020/12/25/LinkedHashMap/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>继承自<code>HashMap</code>，实现了<code>Map&lt;K,V&gt;</code>接口，和<a href="https://www.yuque.com/lmikoto/dweopl/whrnzv" target="_blank" rel="noopener">HashMap</a>非常相似，主要通过重写<code>HashMap</code>中方法的实现。<br>内部维护一个双向链表，每次插入数据、访问、修改数据时，会增加节点或调整链表节点的顺序。<br>允许 key 为 null，value 为 null<br>线程不安全</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p><code>LinkedHashMap</code>内部维护一个双向链表。属性中的 head 和 tail 记录头节点和尾节点。<br>节点是继承<code>HashMap</code>的节点，并在其基础上扩充了 before, after，改造成了双向链表的节点。<br><code>accessOrder</code>为 true 时，迭代顺序是访问顺序(最近访问的会插在链表的后面)，相同 false 的时候遍历顺序为插入顺序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数和<code>HashMap</code>基本相同。多了一个 accessOrder 用于控制迭代时的顺序。默认为 false</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h2><p><code>LinkedHashMap</code>没有重写 put 方法，但重写了 newNode 方法。通过重写<code>newNode</code>方法实现每次新增节点的时候调用<code>linkNodeLast</code>将节点放到链表的尾部。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及最后调用了钩子函数<code>afterNodeInsertion</code>因为这个<code>LinkedHashMap</code>的 removeEldestEntry 一定会返回 false。所以这个方法就没啥用。但是其他的子类会重写<code>removeEldestEntry</code>方法比如<code>LruCache</code>在<code>LinkedHashMap</code>中可以忽略它。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h2><p><code>LinkedHashMap</code>也没有直接重写 remove 方法，remove 主逻辑和<code>HashMap</code>相同。<br>但是重写了<code>afterNodeRemoval</code>方法来删除链表中的节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><p>get 方法和<code>HashMap</code>中的最主要区别是多了<code>accessOrder</code>相关的操作。前面说了如果<code>accessOrder</code>为 true 那么遍历的顺序为访问的顺序。<br><code>afterNodeAccess</code>方法会把访问的节点放到链表的最后。<br><code>afterNodeAccess</code>会修改 modCount。因此在遍历<code>LinkedHashMap</code>的时候如果访问元素也会触发<code>fail-fast</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="containsValue"><a href="#containsValue" class="headerlink" title="containsValue"></a>containsValue</h2><p>重写了<code>containsValue</code>方法。直接使用链表进行遍历。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">        V v = e.value;</span><br><span class="line">        <span class="keyword">if</span> (v == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="entrySet"><a href="#entrySet" class="headerlink" title="entrySet"></a>entrySet</h2><p>重写了<code>entrySet</code>方法<br>遍历是直接使用双向链表进行遍历的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>LinkedHashMap</code>相比<code>HashMap</code>而言，仅重写了几个方法，以改变它迭代的遍历顺序。每次插入数据，访问数据，修改数据都会增加节点或者调整节点的顺序。已决定迭代输出的顺序。</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>解决哈希冲突的办法</title>
    <url>/2020/12/19/%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><h2 id="产生哈希冲突的原因"><a href="#产生哈希冲突的原因" class="headerlink" title="产生哈希冲突的原因"></a>产生哈希冲突的原因</h2><p>由于哈希函数计算的范围是无限的，而计算后的结果范围是有限的，因此总会存在不同的数据计算得出的值是相同的。这就是哈希冲突。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><p>开放定址法也称为再散列，从发生冲突的那个单元开始，按照一定的次序，从哈希表里面找到一个空闲的单元，将对应的元素放入其中。<br><img src="/images/f338bfcac34e7f2121c9b9eee64efede.svg" alt=""><br>其中 H(key)为哈希函数, length 为哈希表的长度，Di 为增量序列，增量序列的计算方式不一样，对应的散列方法也不一样。主要有以下三种</p><h4 id="线性探查法"><a href="#线性探查法" class="headerlink" title="线性探查法"></a>线性探查法</h4><p>线性探查法中</p><p>###</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2020/12/14/HashMap/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HashMap 是 Map 接口的实现类。基于哈希表，提供了基于 key-value 键值对的操作。允许 null 值和 null 键。不保证 map 的顺序，特别是不保证顺序是一直不变的。<br>HashMap 不是线程安全的。<br>HashMap 是集合框架中的一成员。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>HashMap 采用数组 + 链表 + 红黑树实现的，当链表长度超过阈值 8 的时候，将链表转换成红黑树。<br><img src="/images/1608349304876-a0798768-a5e7-4d06-8083-c1bcb51cac07.png" alt="image.png"></p><h2 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认初始化容量 容量必须是2的倍数 默认是16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大所能容纳的key-value个数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树化链表节点的阈值，当某个链表节点大于等于这个长度，则扩大数组容量，或者转换成树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储数据的Node数组，长度是2的倍数</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entrySet方法返回的结果集</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被修改的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容量乘以负载因子的值，如果size的大小等于该值，就会调用resize方法，扩大容量，同时修改该值</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h3><p>默认构造方法会使用默认的负载因子 0.75</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-int-initialCapacity-float-loadFactor"><a href="#HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="HashMap(int initialCapacity, float loadFactor)"></a>HashMap(int initialCapacity, float loadFactor)</h3><p>使用指定的容量和负载因子初始化 HashMap。当并不是指定多少容量就会是多少，tableSizeFor 会把容量变成 2 的次方。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 使用threshold记录一下容量，后面会替换掉的。</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的主要目的是为了把传入的 cap 变成大于等于 cap 并且最接近的一个 2 的次方的数。比如传入 20 返回 32。<br>该方法的本质是把传入参数 cap 的二进制位的非 1 位都变成 1，然后 + 1 获取结果。</p><ul><li><code>n = cap - 1</code>如果该数本身是 2 的 n 次方。比如 32，不进行这个操作会变成 64，而我们预期拿到的是 32，所以这里减 1。</li><li><code>n |= n &gt;&gt;&gt; 1</code><ul><li><code>n &gt;&gt;&gt; 1</code> n 无符号右移一位，n 的最高位右移一位</li><li><code>n | (n &gt;&gt;&gt; 1)</code> n 的最高位一定是 1，经过异或操作之后 n 的最高 1 ～ 2 位都是 1</li></ul></li><li><code>n |= n &gt;&gt;&gt; 2</code><ul><li><code>n &gt;&gt;&gt; 2</code> n 无符号右移 2 位</li><li><code>n | (n &gt;&gt;&gt; 2)</code> 经过操作之后 n 的最高 1 ～ 4 位都是 1</li></ul></li><li><code>n |= n &gt;&gt;&gt; 4</code><ul><li><code>n &gt;&gt;&gt; 4</code> n 无符号右移 4 位</li><li><code>n | (n &gt;&gt;&gt; 4)</code> 经过操作之后 n 的最高 1 ～ 8 位都是 1</li></ul></li><li><code>n |= n &gt;&gt;&gt; 8</code><ul><li><code>n &gt;&gt;&gt; 8</code> n 无符号右移 8 位</li><li><code>n | (n &gt;&gt;&gt; 8)</code> 经过操作之后 n 的最高 1 ～ 16 位都是 1</li></ul></li><li><code>n |= n &gt;&gt;&gt; 16</code><ul><li><code>n &gt;&gt;&gt; 16</code> n 无符号右移 16 位</li><li><code>n | (n &gt;&gt;&gt; 16)</code> 经过操作之后 n 的最高 1 ～ 32 位都是 1</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-int-initialCapacity"><a href="#HashMap-int-initialCapacity" class="headerlink" title="HashMap(int initialCapacity)"></a>HashMap(int initialCapacity)</h3><p>这个方法是用默认的负载因子调用上面那个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#HashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="HashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>HashMap(Map&lt;? extends K, ? extends V&gt; m)</h3><p>使用默认的负载因子拷贝一份 map 对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h2><ol><li>根据 key 获取哈希值</li><li>判断 table 有没有初始化，如果没有初始化调用 resize 进行初始化</li><li>根据 hash 值算出数组的索引，如果该位置没有值则创建 node 放在该位置上</li><li>如果有值，判断 key 是否相等，如果相等则准备覆盖</li><li>如果这个节点本身是树的节点，则调用树的方法插入</li><li>遍历链表判断 key 是否相等，如果找到相等的准备覆盖，如果到了尾部还没有找到的话，则创建节点。如果链表长度大于等于 8 则调用 treeifyBin 进行树化</li><li>如果需要覆盖，则更新旧的节点的 value 为新的 value，返回旧的 value</li><li>如果不是覆盖的情况，size+1 然后和 threshold 进行比较，如果大于则进行扩容，返回 null</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 第一次调用或调用resize进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果对应的槽里没数据，直接新增node放到table上</span></span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 在n为2的次方的时候等价 hash % n</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果key相同，则准备更新节点的value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// hash一致，但是key不一致</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 遍历到了最后还是没有找到key一致的，则插入到链表最后</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到了key相同的准备更新value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key相同的更新value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// size + 1 如果大于threshold进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resize 方法</p><ol><li>先计算 threshold 和 newTab</li><li>创建 newTab 数组，如果原数组中有值，将之前的 table 数组中的值全部放到新的 table 中去</li></ol><p><code>e.hash &amp; oldCap == 0</code>部分的放到原位置，而<code>e.hash &amp; oldCap == 1</code>的部分放到<code>j + oldCap</code>中。<br>前面说过 hash % n 在 n 为 2 的次方的时候等价 (n - 1) &amp; hash 。当 n 为 2 的 m 次方的时候，那么 n 的最高位(第 m+1 位)为 1，其余位为 0，那么 n-1 的二进制表示全部是 1(m+1 位为 0，后 m 位都是 1)，所以<code>(n - 1) &amp; hash</code>本质就是在求 hash 值的低 m 位。进行扩容的时候会把长度变成原来的两倍，假定原来 n=4，hash 的低四位为 bcd。扩容前(n - 1) &amp; hash 为 bcd。扩容之后 n=5。对于 hash 而言，低五位有两种情况，第一种是 1bcd。第二种是 0bcd。而 0bcd 这种情况和原来是相等的。因此<code>e.hash &amp; oldCap == 0</code>部分的放到原位置。而 1bcd = 1000 + bcd 即<code>oldCap + j</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 之前调用过了一次resize进行初始化，第二次再调用resize的时候会走到这个判断中</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果达到了最大长度就不进行扩容了。</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有达到最大长度，容量和阈值扩大两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 调用了带参数的构造方法，第一次调用resize的时会走到这里</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 调用了无参构造方法，第一次调用resize的时候会走到这里</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用了带参数的构造方法，第一次调用resize的时会走到这里，计算新的阈值</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><p>get 方法基本就跟 put 相反的操作。</p><ol><li>计算 key 对应的 hash 值的 index 索引</li><li>如果没有节点返回 null</li><li>有节点的话获取第一个，如果第一个的 key 值刚好相等就直接返回</li><li>判断是否是树节点，如果是调用树的 getNode 获取</li><li>否则遍历链表进行查找。找到返回，没找到返回 null</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="containsKey"><a href="#containsKey" class="headerlink" title="containsKey"></a>containsKey</h2><p>containsKey 是调用 getNode 来实现的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="containsValue"><a href="#containsValue" class="headerlink" title="containsValue"></a>containsValue</h2><p>containsValue 遍历全部节点，存在返回 true，不存在返回 false</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><ol><li>根据 key 得到 hash 值</li><li>根据 key 和 hash 值定位到需要移除的 Node</li><li>将 Node 移除，将 Node 前后的节点连接起来</li><li>返回被移除的 Node</li><li>key-value 数量 - 1，修改次数 + 1</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 第一个元素符合</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 遍历链表直到找到符合的或者到最后</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了节点，把节点进行删除</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">// 修改次数 + 1</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">// size - 1</span></span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><h3 id="replace-K-key-V-oldValue-V-newValue"><a href="#replace-K-key-V-oldValue-V-newValue" class="headerlink" title="replace(K key, V oldValue, V newValue)"></a>replace(K key, V oldValue, V newValue)</h3><ol><li>使用 getNode 方法找到节点</li><li>如果找到的节点的值和 oldValue 相同进行替换，返回 true</li><li>返回 false</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e; V v;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">        e.value = newValue;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="replace-K-key-V-value"><a href="#replace-K-key-V-value" class="headerlink" title="replace(K key, V value)"></a>replace(K key, V value)</h3><ol><li>使用 getNode 方法找到节点</li><li>如果找到的节点进行替换，返回 true</li><li>返回 false</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>清除所有数组中的引用<br>modCount + 1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash 方法"></a>hash 方法</h2><p>上面提到了<code>(n - 1) &amp; hash</code>本质是求 hash 的最后几位。<br>这里的<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>把 h 右移 16 位然后和自己做异或操作，让高位也参与计算，增加随机性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>JDK8源码-LinkedList</title>
    <url>/2020/12/13/JDK8%E6%BA%90%E7%A0%81-LinkedList/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Linkedlist 是一个继承自 AbstractSequentialList 的双向链表，因此可以在双端进行操作。可以被用来当作栈和队列。<br>实现 List 接口可以对列表进行操作<br>实现 Deque 接口，可以将 Linkedlist 作为双端队列使用<br>Linkedlist 实现了 Cloneable 接口，重写了 clone 方法。可以被克隆<br>Linkedlist 实现了 Serializable，支持序列化<br>Linkedlist 是线程不安全的</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>Linkedlist 只有三个属性<br>size: 代表当前有多少个节点，不参与序列化<br>first: 代表第一个节点，不参与序列化<br>last: 代表最后一个节点，不参与序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node 是一个简单的内部类，一个双向连表的节点。<br>item 代表节点存储的元素，<br>next 代表下个节点<br>prev 代表上一个节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="空构造函数"><a href="#空构造函数" class="headerlink" title="空构造函数"></a>空构造函数</h3><p>空构造函数什么也没有做</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用集合作为入参的构造函数"><a href="#使用集合作为入参的构造函数" class="headerlink" title="使用集合作为入参的构造函数"></a>使用集合作为入参的构造函数</h3><ol><li>调用空构造函数创建对象</li><li>调用 addAll 方法，addAll 方法调用重载方法，把集合和当前的 size(作为 index)传入。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addAll 方法执行步骤</p><ol><li>校验是否越界，即传入的 index 不能小于 0，不能大于 size</li><li>将集合转换成数组对象 a</li><li>如果当前的 size 是 index 即在最后添加元素，那么后续节点是 null，前序节点是 linkedlist 的当前最后一个节点。否则就是在中间插入数据，后续节点为当前 index 的节点。而前序节点为当前 index 节点的前一个节点。即下图，要在 index 1 的位置插入 newNode。那么 newNode 的后续节点为原来 index 位置上的节点 node2，newNode 的前序节点为原来 index 位置上的 node2 的前序节点 node1。这里的 NewNode 代表一个元素，如果代表多个元素同样的道理。</li></ol><p><img src="/images/1607838514006-8716f8f1-0fd0-4f7c-b4f8-d7133cc2c5fb.png" alt="image.png"></p><ol start="4"><li>遍历数组 a，组装连表</li><li>size 加上传入集合的数量</li><li>modCout + 1</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h2><h3 id="add-E-e-方法"><a href="#add-E-e-方法" class="headerlink" title="add(E e)方法"></a>add(E e)方法</h3><ol><li>直接将元素添加到链表的最后一个节点。如果原来 linkedList 中的 last 是 null，证明链表中还没有元素，所以会把 newNode 放到 first 位置作为第一个元素，此时 first 和 last 都是 newNode</li><li>size + 1</li><li>modCount + 1</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h3><ol><li>校验是否越界。</li><li>size 和 index 是否相等，如果相等就是在最后新加节点，即和上面的情况一样</li><li>否则调用 linkBefore 进行插入。过程和批量操作类似。只不过这里是单个节点。</li><li>size + 1</li><li>modCount + 1</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><ol><li>校验是否越界</li><li>使用 node 方法获取节点，并返回 item</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是双向连表。所以会先判断一下 index 和 size 的一半的关系。从更靠近的一边进行遍历。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getFirst"><a href="#getFirst" class="headerlink" title="getFirst"></a>getFirst</h2><p>会直接返回 linkedlist 的头节点，如果 linkedList 中没有元素会抛错。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getLast"><a href="#getLast" class="headerlink" title="getLast"></a>getLast</h2><p>会直接返回 linkedlist 的尾节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><h3 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h3><p>调用 removeFirst 方法，因此 remove 方法删除的是第一个节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="removeFirst"><a href="#removeFirst" class="headerlink" title="removeFirst()"></a>removeFirst()</h3><ol><li>移除第一个节点。第一个节点清空。把 linkedList 的 first 变成下个节点。如果此时链表中没有节点了，就把 last 也设置成 null，否则新 first 的前置节点变为 null</li><li>size - 1</li><li>modCount + 1</li><li>返回被删除的元素</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="removeLast"><a href="#removeLast" class="headerlink" title="removeLast()"></a>removeLast()</h3><p>removeLast 和 removeFirst 的操作基本一致，不过操作对象变成了尾元素，因为本身就是双向链表，本质其实是一样的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><ol><li>校验是否越界</li><li>调用 node 方法找到节点</li><li>调用 unlink 摘除节点，并返回移除的数据<ol><li>如果前序节点为 null 证明删除的是第一个元素，所以需要把链表的头节点换成 next</li><li>如果后序节点为 null 证明删除的是最后一个元素，所以需要把链表的尾节点换成 next</li><li>把元素的属性设置成 null 方便垃圾回收</li><li>size - 1</li><li>modCount + 1</li><li>返回被删除元素</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><ol><li>遍历删除第一个等于 o 的元素</li><li>删除成功返回 true 否则返回 false</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h2><ol><li>校验数组是否越界</li><li>把对应位置的元素换成新元素</li><li>返回老元素</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><ol><li>遍历删除所有节点（注释中也有写，这一步不是必须的，单有利于垃圾回收）</li><li>linkList 的头和尾设置成 null</li><li>size 清 0</li><li>modCount + 1</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Clearing all of the links between nodes is "unnecessary", but:</span></span><br><span class="line">    <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">    <span class="comment">//   more than one generation</span></span><br><span class="line">    <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    first = last = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="push-和-pop-方法"><a href="#push-和-pop-方法" class="headerlink" title="push 和 pop 方法"></a>push 和 pop 方法</h2><p>这两个方法是实现 Deque 接口带来的。<br>这两个方法是调用 addFirst 和 removeFirst 实现的。</p><h2 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h2><p>创建一个新数组遍历连表把节点设置到 Object 中返回 Object 数组对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>生成一个 ListItr 的内部类。内部通过遍历实现的，这里就不展开了。同样是线程不安全的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>LinkedList 基于双向链表实现</li><li>线程不安全</li><li>get 元素的时候会发生遍历，距离头节点近就从头节点遍历，否则从为节点进行遍历</li><li>删除元素的时候需要遍历，然后摘除节点</li><li>可以被当作队列和栈使用</li></ul><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>ArrayList</title>
    <url>/2020/12/04/ArrayList/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>ArrayList 是一个动态数组，其容量可以动态增长。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ArrayList 继承了 AbstractList，实现了 List。他是一个数组队列，提供了增加、删除、修改、继承、遍历等功能。<br>ArrayList 实现了 RandmoAccess 接口，提供了随机访问的能力。<br>ArrayList 实现了 Cloneable 接口，重写了 clone 方法。可以被克隆。<br>ArrayList 实现了 Serializable，支持序列化。<br>ArrayList 是线程不安全的，在多线程环境下可以选择 Vector 或者 CopyOnWriteArrayList</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认初始化容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个空的数组对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个空的数组，如果使用无参构造函数，则对象的默认值为该值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际存储对象的数组，不参与序列化</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前数组长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大数组长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 elementData 中的长度是 0，list 的 size 为 0。当进行第一次 add 的时候 elementData 的长度会变成默认的长度 10，这个下面会讲到。</p><h3 id="带-int-的构造函数"><a href="#带-int-的构造函数" class="headerlink" title="带 int 的构造函数"></a>带 int 的构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果传入参数，参数如果大于 0，使用传入的参数初始化 elementData 的数组长度，如果小于 0 抛出异常。如果等于 0,elementData 就是静态常量 EMPTY_ELEMENTDATA 的地址。</p><h3 id="带-Collection-对象的构造函数"><a href="#带-Collection-对象的构造函数" class="headerlink" title="带 Collection 对象的构造函数"></a>带 Collection 对象的构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将 collection 对象转换成数组，并把地址赋给 elementData。</li><li>更新 size 为 elementData 的长度。</li><li>如果 size 不为 0，并且对象不是 Object 对象，Arrays.copyOf 方法进行拷贝。否则把 elementData 的地址换成 EMPTY_ELEMENTDATA 的地址。</li></ol><p>在上述步骤 3 中为什么需要进行额外的一步拷贝操作呢？是因为 Collection 的 toArray 方法的行为和规范不一致。以 Arrays 的内部类 ArrayList 和这篇文章说的 ArrayList 进行对比。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">"list1"</span>);</span><br><span class="line">Object[] array1 = list1.toArray();</span><br><span class="line">System.out.println(array1.getClass().getCanonicalName());<span class="comment">// 输出结果 java.lang.Object[]</span></span><br><span class="line">array1[<span class="number">0</span>] = <span class="keyword">new</span> Object(); <span class="comment">// 正常</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list2 = Arrays.asList(<span class="string">"list2"</span>);</span><br><span class="line">Object[] array2 = list2.toArray();</span><br><span class="line">System.out.println(array2.getClass().getCanonicalName()); <span class="comment">// 输出结果 java.lang.String[]</span></span><br><span class="line">array2[<span class="number">0</span>] = <span class="keyword">new</span> Object(); <span class="comment">// 异常java.lang.ArrayStoreException: java.lang.Object</span></span><br></pre></td></tr></table></figure><p>所以如果该构造函数以 Arrays 的内部类 ArrayList 为入参就回把 elementData 的类型给修改了。对于上面例子，会把 elementData 的类型由 Object[]修改为 String[]。对于细节，可以看一下 Arrays 的内部类 ArrayList 的源码，这里就不展开了。所以此时使用了 Arrays.copyOf 重新修改了一下类型。</p><h2 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h2><h3 id="add-E-e-方法"><a href="#add-E-e-方法" class="headerlink" title="add(E e)方法"></a>add(E e)方法</h3><p>add 主要执行逻辑如下</p><ol><li>确保 size + 1 之后能够存的下下一个数据</li><li>modCount + 1 如果 size + 1 &gt; 数组长度，调用 grow 方法，增长数组长度为当前的 1.5 倍</li><li>新元素存储到 size 的位置上，并且把 size + 1</li><li>返回成功</li></ol><p>入口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算容量<br>当第一次添加元素的时候 minCapacity 为 size + 1 = 1，此时容量变为 DEFAULT_CAPACITY，即 10。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>modCount + 1<br>如果本次添加需要的最小长度大于当前 elementData 的长度进行扩容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组扩容 1.5 倍。<br>如果 1.5 倍还不够则使用 minCapacity 作为数组的长度,注意这里还有溢出的情况，整数位运算扩大 1.5 倍，如果 integer 长度不够 newCapacity 会变成负数。负数减去 minCapacity 也是负数。因此 newCapacity 为负数。会在 hugeCapacity 函数中抛出异常。</p><p>如果扩大 1.5 倍，大于 MAX_ARRAY_SIZE，并且小于 Integer.MAX_VALUE，即 oldCapacity + (oldCapacity &gt;&gt; 1) 没有发生溢出的情况下，会把容量扩大到 Integer.MAX_VALUE。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h3><p>这个方法和上面的 add 方法是非常类似的。</p><ol><li>校验是否越界</li><li>确保 size + 1 之后能够存的下下一个数据。内部过程和上面过程一样，这里就不展开讨论了。</li><li>使用 System.arraycopy 把 index 后面的元素全部移动一位。</li><li>把添加的元素放到 index 的位置上。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><ol><li>校验是否越界</li><li>返回 elementData 对应位置的元素</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h2><ol><li>校验是否越界</li><li>把新元素放到对应的位置上</li><li>返回老元素</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="contain-方法"><a href="#contain-方法" class="headerlink" title="contain 方法"></a>contain 方法</h2><p>直接遍历实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><ol><li>校验数组是否越界</li><li>modCount + 1</li><li>将 index 之后的元素都向前挪一位</li><li>最后一个元素的引用变为 null，方便垃圾回收器回收</li><li>返回被移除的值</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><p>遍历所有元素通过 fastRemove 删除和传入对象相同的值，这里只会移除第一个相同的元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fastRemove 和上面的 remove(int index)很相似，只是不需要进行越界校验和记录移除的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><ol><li>modCount + 1</li><li>遍历 elementData，把引用变成 null。这里没有调整 elementData 的 length</li><li>修改 size 为 0。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sublist"><a href="#sublist" class="headerlink" title="sublist"></a>sublist</h2><ol><li>校验是否越界。</li><li>创建并返回 SubList 这个内部类的对象。这里传入当前 list 的 this 作为如参数。如果修改 sublist 中的值，原来 list 值也会变</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize"></a>trimToSize</h2><ol><li>modCount + 1 这里注意不管最后是否修改都会+1</li><li>如果 size 是 0 返回空数组否则把 elementData 的 length 大于 size 的部分移除（实际是通过创建新数组实现的）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h2><p>直接拷贝一个 elementData 返回</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>创建内部类的 Itr 对象这个内部类 Itr 实现了迭代器 Iterator 接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>校验期待修改的次数，也就是说迭代器对象创建之后，修改数组，再进行遍历就会抛出 ConcurrentModificationException 异常。</li><li>校验游标不能大于等于 size。</li><li>校验游标不能大于等于 elementData 数组的长度。这一步校验大概是为了防并发操作吧。上面校验 size 通过，另一个线程删减了 list 的数组并且 trim 之后会发生这个问题。个人感觉这个操作有点多余，因为 arraylist 本身是线程不安全的，并不会因为这个操作变成线程安全的。</li><li>返回当前游标的元素。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>ArrayList 基于数组实现，可以自动扩容。</li><li>线程不安全。</li><li>add(int index, E element)添加元素会讲 index 后面的元素全部向后移动一位。</li><li>get 直接获取</li><li>remove(Object)需要遍历数组，并且只会删除第一个匹配的元素，删除之后后面的元素都会向前移动一位</li><li>remove(int index)不需要遍历数组，直接删除元素，删除之后 index 后的元素都会向前移动一位</li><li>contains 通过遍历数组实现</li></ul><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Tomcat系统组件</title>
    <url>/2020/10/31/Tomcat%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>Tomcat 有两个身份</p><ul><li>http 服务器</li><li>Tomcat 是一个 Servlet 容器</li></ul><p>Tomcat 即按照 Servlet 规范去实现了 Servlet 容器，同时具有 Http 服务器的功能。<br>Http 服务器接受请求之后交给 Servlet 容器来处理。Servlet 容器通过 Servlet 接口调用业务功能。<strong>Servlet 接口和 Servlet 容器的这一套规范叫做 Servlet 规范</strong><br>**</p><h2 id="Tomcat-Servlet-容器处理流程"><a href="#Tomcat-Servlet-容器处理流程" class="headerlink" title="Tomcat Servlet 容器处理流程"></a>Tomcat Servlet 容器处理流程</h2><ol><li>Http 服务器会把请求信息使用 ServletRequest 对象封装起来</li><li>Servlet 容器拿到请求后根据 url 和 Servlet 的映射关系，找到对应的 Servlet</li><li>如果 Servlet 还没被加载，就用反射生成 Servlet。并调用 Servlet 的 init 方法完成初始化</li><li>调用具体 Servlet 中的方法来出气请求，处理结果使用 ServletResponse 对象封装</li><li>把 ServletResponse 对象转换程 response 返回给 Http 服务器，Http 服务器把请求发送给客户端</li></ol><h2 id="Tomcat-整体架构"><a href="#Tomcat-整体架构" class="headerlink" title="Tomcat 整体架构"></a>Tomcat 整体架构</h2><ol><li>Connector 组件 和客户端浏览器进行交互，进行 socket 通信，将字节流和 Request/Response 等对象进行转换</li><li>容器组件 Servlet 容器处理业务逻辑</li></ol><h2 id="连接器组件-Coyote"><a href="#连接器组件-Coyote" class="headerlink" title="连接器组件 Coyote"></a>连接器组件 Coyote</h2><p>coyote 是对外的接口，客户端通过 coyote 与服务器建立链接，发送请求并接受相应</p><ol><li>Coyote 封装了底层的网络通信（Socket 请求及响应处理）</li><li>Coyote 使 Catalina 容器 与具体的请求协议及 io 操作方式完全解耦</li><li>Coyote 将 Socket 输入转换成 Request 对象，进一步分装之后交给 Catalina 容器进行处理，处理完成后，Catalina 通过 Coyote 提供的 Response 对象写入输出流。</li><li>Coyote 负责的是具体的协议（应用层）和 IO（传输层）的内容</li></ol><h3 id="组件及作用"><a href="#组件及作用" class="headerlink" title="组件及作用"></a>组件及作用</h3><table><thead><tr><th><strong>组件</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>EndPoint</td><td>是 Coyote 通信端点，即通信监听的接口，是具体 Socket 的接收和发送处理器，是对传输层的抽象。用来实现 TCP/IP 协议的</td></tr><tr><td>Processor</td><td>是 Coyote 协议处理接口，Processor 是用来实现 HTTP 协议，Processor 接收来自 EndPoint 的 Socket，读取字节流解析成 Tomcat Request 和 Response 对象，并通过 Adapter 将其提交给容器处理，Processor 是对应的应用层协议抽象。</td></tr><tr><td>ProtocolHandler</td><td>Coyote 协议接口，通过 EndPoint 的 Processor，实现了针对具体协议的处理能力</td></tr><tr><td>Adapter</td><td>将 Tomcat Request 转换成 ServletRequest，再调用容器</td></tr></tbody></table><h2 id="Servlet-容器-Catalina"><a href="#Servlet-容器-Catalina" class="headerlink" title="Servlet 容器 Catalina"></a>Servlet 容器 Catalina</h2><p>Catalina 实例通过加载 server.xml 完成实例的创建，创建并管理一个 Server，Server 创建并管理多个服务，每个服务又可以有多个 Connector 和一个 Container</p><h3 id="Catalina"><a href="#Catalina" class="headerlink" title="Catalina"></a>Catalina</h3><p>负责解析 server.xml。以此来创建服务器 Server 组件并进行管理</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>Server 表示整个 Catalina Servlet 组件以及其他组件，负责组装并启动 Servlet 疫情，连接器，Server 通过实现 Lifcycle 接口，提供了一种优雅的启动和关闭整个系统的方式。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service 是 Server 内部组件，一个 Server 保函多个 Service，他将若干个 Connector 组件绑定到一个 Container</p><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>负责处理用户的 Servlet 请求，并返回对象给 web 用户的模块</p><h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h4><p>表示整个 Catalina 的 Servlet 引擎，用来管理多个虚拟站点，一个 Servlet 最多一个 Engine，但是一个引擎可能包含多个 Host</p><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>代表一个虚拟主机，可以给 Tomcat 配置多个虚拟主机地址，一个虚拟主机下面有多个 Context</p><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>表示一个 Web 应用程序，一个 Web 应用可以包含多个 Wrapper</p><h4 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h4><p>表示一个 Servlet，Wrapper 作为容器的最底层</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Spring Boot run方法流程</title>
    <url>/2020/10/31/Spring%20Boot%20run%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>spring boot 项目的启动文件会调用 <code>SpringApplication.run</code>这个静态方法<br>这个静态方法主要是对 run 方法做了一层静态包装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123;</span><br><span class="line">	// 1 实例化 SpringApplication</span><br><span class="line">   // 2 执行run(args)</span><br><span class="line">   <span class="built_in">return</span> new SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringApplication 的构造方法<code>org.springframework.boot.SpringApplication#SpringApplication(org.springframework.core.io.ResourceLoader, java.lang.Class&lt;?&gt;...)</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">	this.resourceLoader = resourceLoader;</span><br><span class="line">	Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line">   // 项目启动类的class</span><br><span class="line">	this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">   // 设置web应用类型 servlet应用 或者 reactive应用（webflux）通过判断class path中是否存在 是否有相关依赖实现的</span><br><span class="line">	this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">	this.bootstrappers = new ArrayList&lt;&gt;(getSpringFactoriesInstances(Bootstrapper.class));</span><br><span class="line">   // 设置初始化器 实际上就是配置在 spring.factories中的 ApplicationContextInitializer类型</span><br><span class="line">	setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">   // 设置监听器  实际上就是配置在 spring.factories中的 ApplicationListener类型</span><br><span class="line">	setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">   // 初始化 mainApplicationClass 用于推断并设置项目main方法启动的主程序启动类</span><br><span class="line">	this.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看 run 方法<br><code>org.springframework.boot.SpringApplication#run</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public ConfigurableApplicationContext  run(String... args) &#123;</span><br><span class="line">	StopWatch stopWatch = new StopWatch();</span><br><span class="line">	stopWatch.start();</span><br><span class="line">	DefaultBootstrapContext bootstrapContext = createBootstrapContext();</span><br><span class="line">	ConfigurableApplicationContext context = null;</span><br><span class="line">	// 配置 handless 属性</span><br><span class="line">	configureHeadlessProperty();</span><br><span class="line"></span><br><span class="line">	// 1 获取并启动监听器</span><br><span class="line">	// 从spring.factories 中读取 SpringApplicationRunListener</span><br><span class="line">	SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">	listeners.starting(bootstrapContext, this.mainApplicationClass);</span><br><span class="line">	try &#123;</span><br><span class="line">		// 初始化默认应用的参数类 参数可以在spring中访问 比如 --server.port=8080</span><br><span class="line">		ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line"></span><br><span class="line">		// 2 environment 预配置 创建和配置environment</span><br><span class="line">		// 遍历并调用所有的 SpringApplicationRunListener的 environmentPrepared方法</span><br><span class="line">		ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line"></span><br><span class="line">		configureIgnoreBeanInfo(environment);</span><br><span class="line">		// 准备banner打印器</span><br><span class="line">		Banner printedBanner = printBanner(environment);</span><br><span class="line"></span><br><span class="line">		// 3 创建Spring 容器</span><br><span class="line">		context = createApplicationContext();</span><br><span class="line">		context.setApplicationStartup(this.applicationStartup);</span><br><span class="line"></span><br><span class="line">		// 4 前置处理</span><br><span class="line">		// 将启动类注入容器，为后续开启自动化配置奠定基础</span><br><span class="line">		// 主要是容器刷新前的准备动作。</span><br><span class="line">		prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line"></span><br><span class="line">		// 5 刷新容器</span><br><span class="line">		refreshContext(context);</span><br><span class="line"></span><br><span class="line">		// 6 后置处理</span><br><span class="line">		// 没有实现可以进行扩展</span><br><span class="line">		afterRefresh(context, applicationArguments);</span><br><span class="line">		stopWatch.stop();</span><br><span class="line">		<span class="keyword">if</span> (this.logStartupInfo) &#123;</span><br><span class="line">			new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">		&#125;</span><br><span class="line">		// 7 结束执行通知</span><br><span class="line">		listeners.started(context);</span><br><span class="line">		// 8 执行runner</span><br><span class="line">		// spring boot 提供了 ApplicationRunner 和CommandLineRunner两种接口</span><br><span class="line">		callRunners(context, applicationArguments);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		handleRunFailure(context, ex, listeners);</span><br><span class="line">		throw new IllegalStateException(ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 9 发布应用上下文就绪事件</span><br><span class="line">	try &#123;</span><br><span class="line">		listeners.running(context);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		handleRunFailure(context, ex, null);</span><br><span class="line">		throw new IllegalStateException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Spring @Import 注解实现原理</title>
    <url>/2020/10/29/Spring%20@Import%20%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>@Import 注解用于注入指定的类属性 value 中 class 分为三类</p><ul><li>普通类直接注入</li><li>实现 ImportSelector 接口的类</li><li>实现 ImportBeanDefinitionRegistrar 接口的类</li></ul><p>说明：</p><ul><li>ImportSelector:返回需要导入的组件的全类名数组</li><li>ImportBeanDefinitionRegistrar:手动注册 bean 到容器中</li></ul><p>Spring @Import 初始化是在 refresh 方法中的<code>invokeBeanFactoryPostProcessors(beanFactory)</code> 中进行初始化的。<br>具体过程在<code>org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry</code>中<br>这里主要说@Import 注解，因此忽略@Component @CompomentScan @Bean 等直接到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>在<code>getImports</code>中调入<br>org.springframework.context.annotation.ConfigurationClassParser#collectImports</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectImports</span><span class="params">(SourceClass sourceClass, Set&lt;SourceClass&gt; imports, Set&lt;SourceClass&gt; visited)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (visited.add(sourceClass)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (SourceClass annotation : sourceClass.getAnnotations()) &#123;</span><br><span class="line">			String annName = annotation.getMetadata().getClassName();</span><br><span class="line">			<span class="keyword">if</span> (!annName.equals(Import<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">				collectImports(annotation, imports, visited);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑还是很简单的。使用 visited 作为来去重，如果注解上的注解上还有@Import，就递归调用，否则把@Import 注解中 value 的值塞到 import 中。</p><p><code>org.springframework.context.annotation.ConfigurationClassParser#processImports</code><br>省略校验的过程，这里的三个分之逻辑刚好对用@Import 的三个功能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (SourceClass candidate : importCandidates) &#123;</span><br><span class="line">    <span class="keyword">if</span> (candidate.isAssignable(ImportSelector<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        <span class="comment">// Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span></span><br><span class="line">        Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">        ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">            selector, <span class="keyword">this</span>.environment, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.registry);</span><br><span class="line">        <span class="keyword">if</span> (selector <span class="keyword">instanceof</span> DeferredImportSelector) &#123;</span><br><span class="line">            <span class="keyword">this</span>.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">            Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line">            processImports(configClass, currentSourceClass, importSourceClasses, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        <span class="comment">// Candidate class is an ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">        <span class="comment">// delegate to it to register additional bean definitions</span></span><br><span class="line">        Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">        ImportBeanDefinitionRegistrar registrar =</span><br><span class="line">            BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">            registrar, <span class="keyword">this</span>.environment, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.registry);</span><br><span class="line">        configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">        <span class="comment">// process it as an @Configuration class</span></span><br><span class="line">        <span class="keyword">this</span>.importStack.registerImport(</span><br><span class="line">            currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br><span class="line">        processConfigurationClass(candidate.asConfigClass(configClass));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然@Import 本质其实还是一种加载 Bean 的方式，因此最后都会被丢到 BeanDefinition 中，这个通过 ide 的 find useage 很容易找到。</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Spring Boot自动配置原理</title>
    <url>/2020/10/25/Spring%20Boot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>为什么 Spring Boot 可以自动配置？<br>为什么 Spring Boot 默认扫描的包是启动类所在的包和子包？</p><p>Spring Boot 的自动配置功能是<code>@EnableAutoConfiguration</code>注解实现的。<br><code>@EnableAutoConfiguration</code>中有两个重要的注解</p><h2 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h2><p>这个注解主要的功能都在 import 的<code>org.springframework.boot.autoconfigure.AutoConfigurationPackages.Registrar</code>中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN = AutoConfigurationPackages<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(BeanDefinitionRegistry registry, String... packageNames)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (registry.containsBeanDefinition(BEAN)) &#123;</span><br><span class="line">		BasePackagesBeanDefinition beanDefinition = (BasePackagesBeanDefinition) registry.getBeanDefinition(BEAN);</span><br><span class="line">		beanDefinition.addBasePackages(packageNames);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		registry.registerBeanDefinition(BEAN, <span class="keyword">new</span> BasePackagesBeanDefinition(packageNames));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里判断了一下<code>AutoConfigurationPackages</code>这个类是否在<code>BeanDefinitionRegistry</code>中，如果不在就塞进去。这里把当前的包路径给穿进去。这就是为什么 Spring Boot 默认只能扫描启动类所在的包以及子包。因为这个注解是打在启动类上的，拿到的 packageName 就是启动类所在的 package。</p><h2 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)"></a>@Import(AutoConfigurationImportSelector.class)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">       <span class="comment">// 判断是否开启自动配置</span></span><br><span class="line">	<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">		<span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">	&#125;</span><br><span class="line">	AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">	<span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑都在 getAutoConfigurationEntry 里面，再来看一下这个。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">		<span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">	&#125;</span><br><span class="line">	AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">       <span class="comment">// 获取候选的自动配置的列表</span></span><br><span class="line">	List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">       <span class="comment">// 用set去重</span></span><br><span class="line">	configurations = removeDuplicates(configurations);</span><br><span class="line">       <span class="comment">// 从注解中拿到要排除的</span></span><br><span class="line">	Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">       <span class="comment">// 校验要排除的是否在自动配置列表</span></span><br><span class="line">	checkExcludedClasses(configurations, exclusions);</span><br><span class="line">	configurations.removeAll(exclusions);</span><br><span class="line">       <span class="comment">// 排除掉filter的</span></span><br><span class="line">       <span class="comment">// 这里主要是 处理各种 @Conditional</span></span><br><span class="line">       <span class="comment">// spring-autoconfigure-metadata</span></span><br><span class="line">	configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">       <span class="comment">// 出发 auto-config的事件的接口</span></span><br><span class="line">	fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取候选的自动配置列表<br><code>org.springframework.boot.autoconfigure.AutoConfigurationImportSelector#getCandidateConfigurations</code><br>这里很简单只是调用了<code>org.springframework.core.io.support.SpringFactoriesLoader#loadFactoryNames</code> 然后有调用了重载方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-INF/spring.factories"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">                String[] factoryImplementationNames =</span><br><span class="line">                    StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line">                <span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">                    result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;())</span><br><span class="line">                        .add(factoryImplementationName.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Replace all lists with unmodifiable lists containing unique elements</span></span><br><span class="line">        result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()</span><br><span class="line">                          .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));</span><br><span class="line">        cache.put(classLoader, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location ["</span> +</span><br><span class="line">                                           FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>autoconfig 的配置未见路径是<code>META-INF/spring.factories</code>也是在这个地方写死的。<br>这里其实已经到了 spring 的范畴了，并不属于 spring boot 的东西了。</p><p>这里获取到了 name 之后，会在@Import 那里转换成 BeanDefination，之后被加载程 Bean</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Spring Data Jpa代理对象产生过程</title>
    <url>/2020/10/19/Spring%20Data%20Jpa%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>Spring Data Jpa(下文简称 jpa) 开发的时候只需要写接口，不需要写实现。jpa 实际上是通过动态代理来实现这个过程的。</p><p>这里主要分析由注解的方式注入的流程。<br><code>@``EnableJpaRepositories</code>注解中 import 了<code>JpaRepositoriesRegistrar</code>，而<code>JpaRepositoriesRegistrar</code>继承了<code>org.springframework.data.repository.config.RepositoryBeanDefinitionRegistrarSupport</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(annotationMetadata, <span class="string">"AnnotationMetadata must not be null!"</span>);</span><br><span class="line">    Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null!"</span>);</span><br><span class="line">    Assert.notNull(<span class="keyword">this</span>.resourceLoader, <span class="string">"ResourceLoader must not be null!"</span>);</span><br><span class="line">    <span class="keyword">if</span> (annotationMetadata.getAnnotationAttributes(<span class="keyword">this</span>.getAnnotation().getName()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AnnotationRepositoryConfigurationSource configurationSource = <span class="keyword">new</span> AnnotationRepositoryConfigurationSource(annotationMetadata, <span class="keyword">this</span>.getAnnotation(), <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment, registry);</span><br><span class="line">        RepositoryConfigurationExtension extension = <span class="keyword">this</span>.getExtension();</span><br><span class="line">        RepositoryConfigurationUtils.exposeRegistration(extension, registry, configurationSource);</span><br><span class="line">        RepositoryConfigurationDelegate delegate = <span class="keyword">new</span> RepositoryConfigurationDelegate(configurationSource, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment);</span><br><span class="line">        delegate.registerRepositoriesIn(registry, extension);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后两行可以看出，<code>AbstractRepositoryConfigurationSourceSupport</code>对<code>Repository</code>的 Bean 进行了定义。</p><p>在<code>registerRepositoriesIn</code>这里读了全部的 JPA 接口，并且创建了<code>BeanDefinition</code>。这里只是产生了<code>BeanDefinition，实际上生成bean是在</code></p><p><code>org.springframework.data.repository.core.support.RepositoryFactorySupport#getRepository</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getRepository</span><span class="params">(Class&lt;T&gt; repositoryInterface, RepositoryFragments fragments)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(LogMessage.format(<span class="string">"Initializing repository instance for %s…"</span>, repositoryInterface.getName()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Assert.notNull(repositoryInterface, <span class="string">"Repository interface must not be null!"</span>);</span><br><span class="line">	Assert.notNull(fragments, <span class="string">"RepositoryFragments must not be null!"</span>);</span><br><span class="line"></span><br><span class="line">	RepositoryMetadata metadata = getRepositoryMetadata(repositoryInterface);</span><br><span class="line">	RepositoryComposition composition = getRepositoryComposition(metadata, fragments);</span><br><span class="line">	RepositoryInformation information = getRepositoryInformation(metadata, composition);</span><br><span class="line"></span><br><span class="line">	validate(information, composition);</span><br><span class="line"></span><br><span class="line">	Object target = getTargetRepository(information);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create proxy</span></span><br><span class="line">	ProxyFactory result = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">	result.setTarget(target);</span><br><span class="line">	result.setInterfaces(repositoryInterface, Repository<span class="class">.<span class="keyword">class</span>, <span class="title">TransactionalProxy</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (MethodInvocationValidator.supports(repositoryInterface)) &#123;</span><br><span class="line">		result.addAdvice(<span class="keyword">new</span> MethodInvocationValidator());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result.addAdvisor(ExposeInvocationInterceptor.ADVISOR);</span><br><span class="line"></span><br><span class="line">	postProcessors.forEach(processor -&gt; processor.postProcess(result, information));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (DefaultMethodInvokingMethodInterceptor.hasDefaultMethods(repositoryInterface)) &#123;</span><br><span class="line">		result.addAdvice(<span class="keyword">new</span> DefaultMethodInvokingMethodInterceptor());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ProjectionFactory projectionFactory = getProjectionFactory(classLoader, beanFactory);</span><br><span class="line">	Optional&lt;QueryLookupStrategy&gt; queryLookupStrategy = getQueryLookupStrategy(queryLookupStrategyKey,</span><br><span class="line">			evaluationContextProvider);</span><br><span class="line">	result.addAdvice(<span class="keyword">new</span> QueryExecutorMethodInterceptor(information, projectionFactory, queryLookupStrategy,</span><br><span class="line">			namedQueries, queryPostProcessors, methodInvocationListeners));</span><br><span class="line"></span><br><span class="line">	composition = composition.append(RepositoryFragment.implemented(target));</span><br><span class="line">	result.addAdvice(<span class="keyword">new</span> ImplementationMethodExecutionInterceptor(information, composition, methodInvocationListeners));</span><br><span class="line"></span><br><span class="line">	T repository = (T) result.getProxy(classLoader);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger</span><br><span class="line">				.debug(LogMessage.format(<span class="string">"Finished creation of repository instance for &#123;&#125;."</span>, repositoryInterface.getName()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> repository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先去获取我们写的 repository 接口的元数据，包括实体的 ID 类型，管理的实体类型等。接着获取 repository 的组合，主要包含 repository 的方法信息。然后再根据它俩的组合得到一个 target。这个 target 其实就是一个 SimpleJpaRepository 实体，里面包含了一些通用的方法。只有这些还不够，于是有了后面的代理工厂，对这个 target 进行进一步处理。包括事务支持，异常处理和 SQL 创造等。</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Spring MVC Handler方法执行过程</title>
    <url>/2020/10/17/Spring%20MVC%20Handler%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>这里主要来看现在最常用的注解方式的执行过程<br><code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#handleInternal</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	ModelAndView mav;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 请求方式校验, 415错误就是在这里抛出去的</span></span><br><span class="line">	checkRequest(request);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是否需要支持session同步</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">		HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 生成唯一key</span></span><br><span class="line">			Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">               <span class="comment">// 加锁</span></span><br><span class="line">			<span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">                   <span class="comment">// 对HanderMethod进行参数适配,并调用handler</span></span><br><span class="line">				mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 对HanderMethod进行参数适配,并调用handler</span></span><br><span class="line">			mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 对HanderMethod进行参数适配,并调用handler</span></span><br><span class="line">		mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">			applyCacheSeconds(response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			prepareResponse(response);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很容可以看出主要的执行逻辑都在<code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#invokeHandlerMethod</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 从全局或者对应的Controller拿InitBinder注解的方法,用于进行参数绑定</span></span><br><span class="line">		WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">           <span class="comment">// 获取容器中全局配置的和当前Method对应的Controller中配置的ModelAttribute 进行配置会在调用前执行</span></span><br><span class="line">		ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 将handlerMethod 封装了一下</span></span><br><span class="line">		ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 设置当前容器配置的参数解器</span></span><br><span class="line">			invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 设置当前配置的返回值解析起</span></span><br><span class="line">			invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">		&#125;</span><br><span class="line">           <span class="comment">// 前面创建的binderFactory也塞进来</span></span><br><span class="line">		invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">		invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">		ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">           <span class="comment">// request的属性塞进去</span></span><br><span class="line">		mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">           <span class="comment">// 调用前面获取到的@ModelAttribute方法</span></span><br><span class="line">           <span class="comment">// 从而达到@ModelAttribute标注的方法能在目标的Hander之前调用</span></span><br><span class="line">           <span class="comment">// 说白了就是设置参数</span></span><br><span class="line">		modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">		mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">		AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">		asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">		asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">		asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">		asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">		asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">			Object result = asyncManager.getConcurrentResult();</span><br><span class="line">			mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">			asyncManager.clearConcurrentResult();</span><br><span class="line">			LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">				String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">				<span class="keyword">return</span> <span class="string">"Resume with async result ["</span> + formatted + <span class="string">"]"</span>;</span><br><span class="line">			&#125;);</span><br><span class="line">			invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 对请求参数进行处理,调用对应的方法,并且返回一个封装的ModelAndView</span></span><br><span class="line">		invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">		<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 对ModelAndView进行处理,主要是判断是否进行了重定向</span></span><br><span class="line">           <span class="comment">// 如果进行了重定向需要将FlasAttributes封装到新的请求中</span></span><br><span class="line">		<span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		webRequest.requestCompleted();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#invokeAndHandle</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">		Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 对目标的handler的参数进行处理,并且调用目标handler</span></span><br><span class="line">	Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">       <span class="comment">// 设置返回状态</span></span><br><span class="line">	setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">			disableContentCachingIfNecessary(webRequest);</span><br><span class="line">			mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">		mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">	Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">"No return value handlers"</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 处理返回值</span></span><br><span class="line">		<span class="keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">				returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">		Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将request参数转换为当前handler的参数形式</span></span><br><span class="line">	Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">"Arguments: "</span> + Arrays.toString(args));</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 反射调用目标方法</span></span><br><span class="line">	<span class="keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.web.method.support.InvocableHandlerMethod#getMethodArgumentValues</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span><br><span class="line">		Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取当前handler所声明的所有参数 包括参数名,参数类型,参数位置,所标注的注解等属性</span></span><br><span class="line">	MethodParameter[] parameters = getMethodParameters();</span><br><span class="line">	<span class="keyword">if</span> (ObjectUtils.isEmpty(parameters)) &#123;</span><br><span class="line">		<span class="keyword">return</span> EMPTY_ARGS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Object[] args = <span class="keyword">new</span> Object[parameters.length];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">		MethodParameter parameter = parameters[i];</span><br><span class="line">		parameter.initParameterNameDiscovery(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">           <span class="comment">// providedArgs是调用方提供的参数,主力主要判断这些参数中是否有当前类型.有则直接使用调用方提供的参数,对于</span></span><br><span class="line">           <span class="comment">// 请求处理,这里拿不到值</span></span><br><span class="line">		args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line">		<span class="keyword">if</span> (args[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">           <span class="comment">// 遍历容器中的ArgumentResolver,判断哪种类型的Resolver</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatArgumentError(parameter, <span class="string">"No suitable resolver"</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 进行参数转换</span></span><br><span class="line">			args[i] = <span class="keyword">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="keyword">this</span>.dataBinderFactory);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="comment">// Leave stack trace for later, exception may actually be resolved and handled...</span></span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				String exMsg = ex.getMessage();</span><br><span class="line">				<span class="keyword">if</span> (exMsg != <span class="keyword">null</span> &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;</span><br><span class="line">					logger.debug(formatArgumentError(parameter, exMsg));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Spring MVC处理请求流程</title>
    <url>/2020/10/17/Spring%20MVC%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>Spring MVC 是对 Servlet 的封装。在 Web 项目中配置的 Servlet 是<code>org.springframework.web.servlet.DispatcherServlet</code><br>doGet、doPost 这些方法的实现是在他的父类<code>FrameworkServlet</code>中，然后经过一系列的调研到了<br><code>org.springframework.web.servlet.DispatcherServlet#doDispatch</code><br>这个方法大致有四个流程</p><ol><li>调用<code>getHandler</code>获取能够处理当前请求的执行链<code>HandlerExecutionChain</code>。</li><li>调用<code>getHandlerAdapter</code>获取能够执行 Handler 的适配器。</li><li>适配器调用 Handler 执行方法，统一返回 ModelAndView 对象。</li><li>调用 processDispatchResult 方法完成视图的渲染。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 处理上传文件请求</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 取得当前请求 Handler</span></span><br><span class="line">            <span class="comment">// 不是直接返回Controller 而是返回HandlerExecutionChain</span></span><br><span class="line">            <span class="comment">// 该对象封装了Handler和Interceptor</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 没找到 404</span></span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 获取处理请求的适配器</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理last-modified请求头 一些缓存的东西</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拦截器</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 实际处理请求，返回结果的视图对象</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 结果视图处理，如果没有设置默认视图，给一个默认的视图名称，就是请求路径</span></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">// 拦截器 postHandler</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 页面渲染</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                               <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// 异步的因为前面return了，会直接到这里</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getHandler"><a href="#getHandler" class="headerlink" title="getHandler"></a>getHandler</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 在运行的时候这个list里面会有两个元素</span></span><br><span class="line">        <span class="comment">// BeanNameUrlHandlerMapping 这个是早期用xml配置的形式用的</span></span><br><span class="line">        <span class="comment">// RequestMappingHandlerMapping 注解的形式</span></span><br><span class="line">        <span class="keyword">for</span> (HandlerMapping mapping : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">            HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的过程 <a href="https://www.yuque.com/lmikoto/lmikoto/gv5dn0" target="_blank" rel="noopener">https://www.yuque.com/lmikoto/lmikoto/gv5dn0</a></p><h2 id="getHandlerAdapter"><a href="#getHandlerAdapter" class="headerlink" title="getHandlerAdapter"></a>getHandlerAdapter</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历适配器，选择支持的适配器</span></span><br><span class="line">       	<span class="comment">// HttpRequestHandlerAdapter 处理以继承HttpRequestHandler的方式实现的Handler</span></span><br><span class="line">        <span class="comment">// SimpleControllerHandlerAdapter 处理实现Controller接口定义的Handler</span></span><br><span class="line">        <span class="comment">// RequestMappingHandlerAdapter 处理注解形式定义的Handler</span></span><br><span class="line">        <span class="keyword">for</span> (HandlerAdapter adapter : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line">                <span class="keyword">return</span> adapter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler +</span><br><span class="line">                               <span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>jdk spi</title>
    <url>/2020/10/13/jdk%20spi/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>service provider interface</p><h2 id="JDK-SPI-机制"><a href="#JDK-SPI-机制" class="headerlink" title="JDK SPI 机制"></a>JDK SPI 机制</h2><p>当服务的提供者提供了一种接口的实现之后，需要在 Classpath 下的 META-INF/services/ 目录里创建一个以服务接口命名的文件，此文件记录了该 jar 包提供的服务接口的具体实现类。当某个应用引入了该 jar 包且需要使用该服务时，JDK SPI 机制就可以通过查找这个 jar 包的 META-INF/services/ 中的配置文件来获得具体的实现类名，进行实现类的加载和实例化，最终使用该实现类完成业务功能。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><a href="https://github.com/lmikoto/java-demo/tree/master/jdk-demo/jdk-spi-demo" target="_blank" rel="noopener">https://github.com/lmikoto/java-demo/tree/master/jdk-demo/jdk-spi-demo</a></p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>使用<code>java.util.ServiceLoader#load</code>经过如下链路<br><img src="/images/1602756395196-13244035-85e6-4659-8feb-649bcc166a96.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存用于存放Service实例</span></span><br><span class="line"><span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清理缓存</span></span><br><span class="line">    providers.clear();</span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用的链路其实是到了<code>LazyIterator</code>中。<br>该迭代器最后调用到<code>java.util.ServiceLoader.LazyIterator#hasNextService</code>和<code>java.util.ServiceLoader.LazyIterator#nextService</code>中</p><p>先来看<code>hasNextService</code>方法。该方法的主要负责查找 SPI 配置文件，并解析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span></span><br><span class="line"></span><br><span class="line">Enumeration&lt;URL&gt; configs = <span class="keyword">null</span>;</span><br><span class="line">Iterator&lt;String&gt; pending = <span class="keyword">null</span>;</span><br><span class="line">String nextName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// SPI配置文件的全路径</span></span><br><span class="line">            String fullName = PREFIX + service.getName();</span><br><span class="line">            <span class="comment">// 加载配置文件</span></span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历配置文件中内容，及各个实现类的路径</span></span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析每一行到迭代器中</span></span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看<code>nextService</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    String cn = nextName;</span><br><span class="line">    nextName = <span class="keyword">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加载nextName指定的类</span></span><br><span class="line">        c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验一下是不是对应的接口实现</span></span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建实现类的对象</span></span><br><span class="line">        S p = service.cast(c.newInstance());</span><br><span class="line">        <span class="comment">// 丢到缓存中</span></span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>,</span><br><span class="line">             x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>java 桥接方法</title>
    <url>/2020/10/12/java%20%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><h2 id="什么是桥接方法"><a href="#什么是桥接方法" class="headerlink" title="什么是桥接方法"></a>什么是桥接方法</h2><p>桥接方法是在 JDK1.5 引入泛型之后，为了使 Java 的泛型方法生成的字节码和之前的版本兼容，由编译器自动生成的方法。</p><p>可以通过<code>Method.isBridge()</code>方法来判断一个方法是否是桥接方法。在生成的字节码文件中，桥接方法会被标记为 ACC_BRIDGE 和 ACC_SYNTHETIC。</p><h2 id="什么时候会生成桥接方法"><a href="#什么时候会生成桥接方法" class="headerlink" title="什么时候会生成桥接方法"></a>什么时候会生成桥接方法</h2><p><a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4.5</a><br>在一个子类在继承或实现一个父类或接口的范型方法时，在子类中明确制定了范型的类型。在编译的时候会生成桥接方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Parent</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getName</span><span class="params">(T name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Parent</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试着用反射抓一下 Child 的方法。<br><img src="/images/1602516922094-b1ffe0e8-87c6-48a8-bf56-8c05be16c703.png" alt="image.png"><br>会发现生成了两个方法。而参数时 Object 的那个就是桥接方法。</p><h2 id="为什么会生成桥接方法"><a href="#为什么会生成桥接方法" class="headerlink" title="为什么会生成桥接方法"></a>为什么会生成桥接方法</h2><p>个人感觉时为了兼容之前的设计。</p><p>以上面的例子为例。对应的接口 Parent。在编译之后，实际上 T 会转变成 Object。如果不生成桥接方法，那么子类就没有实现接口中的该方法，导致语法错误（子类必须实现接口中的所有方法）。</p><h2 id="如何通过桥接方法获取实际方法"><a href="#如何通过桥接方法获取实际方法" class="headerlink" title="如何通过桥接方法获取实际方法"></a>如何通过桥接方法获取实际方法</h2><p>我们在通过反射进行方法调用时，如果获取到桥接方法对应的实际的方法呢？可以查看<code>spring中org.springframework.core.BridgeMethodResolver</code>类的源码。实际上是通过判断方法名、参数的个数以及泛型类型参数来获取的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/f641385712/article/details/88767877" target="_blank" rel="noopener">https://blog.csdn.net/f641385712/article/details/88767877</a><br><a href="https://blog.csdn.net/mhmyqn/article/details/47342577" target="_blank" rel="noopener">https://blog.csdn.net/mhmyqn/article/details/47342577</a></p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Spring MVC组件</title>
    <url>/2020/10/12/Spring%20MVC%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>这里说的 Spring MVC 组件指的是 Spring MVC 入口<code>DispatcherServlet</code>中的九个重要的私有变量。这些组件都是接口。可以自由扩展。</p><h3 id="HandlerMapping-处理器映射器"><a href="#HandlerMapping-处理器映射器" class="headerlink" title="HandlerMapping 处理器映射器"></a>HandlerMapping 处理器映射器</h3><p><code>HandlerMapping</code>是用来查找<code>Hanlder</code>的，<code>Hanlder</code>具体的表现形式<del>可以是类（继承或实现接口基本没人这么用了）</del>，也可以是方法。比如标注了<code>@RequestMapping</code>的方法都是<code>Hanlder</code>。<code>Handler</code>负责具体的请求处理。在请求到达之后<code>HandlerMapping</code>的作用就是找到对应的处理的<code>Handler</code>和<code>Interceptor</code></p><h3 id="HanlderAdapter-处理器适配器"><a href="#HanlderAdapter-处理器适配器" class="headerlink" title="HanlderAdapter 处理器适配器"></a>HanlderAdapter 处理器适配器</h3><p><code>HanlderAdapter</code>是一个适配器。Spring MVC 中的<code>Hanlder</code>除了注解标注还有别的形式（虽然不常用）。Spring MVC 把请求转发给<code>Servlet</code>的时候。<code>HanlderAdapter</code>用来适配不同种类的<code>Hanlder</code></p><h3 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h3><p><code>HanlderExceptionResolver</code>用于处理<code>Handler</code>产生的异常情况。</p><h3 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h3><p>视图解析器。用于将 String 类型的视图和 Local 解析成 View 类型的视图。只有一个<code>resolveViewName</code>方法。将 Controller 层返回的 String 类型的视图名称会在这里转换成<code>View</code>对象。<br>ViewResolver 在这个过程中做两件事。</p><ul><li>找到渲染的模版</li><li>找到视图类型 比如 jsp</li></ul><h3 id="RequestToViewNameTranslator"><a href="#RequestToViewNameTranslator" class="headerlink" title="RequestToViewNameTranslator"></a>RequestToViewNameTranslator</h3><p>从请求中获取 ViewName。因为 ViewResolve 是根据 ViewName 去进行查找 View 的。但有的<code>Handler</code>处理完之后没有设置 View 和 ViewName，这个时候会通过这个组件从 Request 查找 ViewName，实际上是 path</p><h3 id="LocaleResolver"><a href="#LocaleResolver" class="headerlink" title="LocaleResolver"></a>LocaleResolver</h3><p>用于从请求中解析出 Local，这个组件是 i18n 的基础。</p><h3 id="ThemeResolver"><a href="#ThemeResolver" class="headerlink" title="ThemeResolver"></a>ThemeResolver</h3><p>用来解析主题的。主题是样式、图片及他们所形成的显示效果集合。一套主题对应一个 properties 文件。<br><code>ThemeResolver</code>负责从请求中解析出主题名。ThemeResolver 根据主题名找出具体的主题，其抽象就是 Theme，可以通过 Theme 获取主题和具体资源。现在一般都不用了。</p><h3 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h3><p>MultipartResolver 用于上传请求，通过将普通请求包装成<code>MultipartHttpServletRequest</code>来实现的，是普通的请求拥有上传文件的功能。</p><h3 id="FlashMapManager"><a href="#FlashMapManager" class="headerlink" title="FlashMapManager"></a>FlashMapManager</h3><p>FlashMap 用于重定向的时候参数传递。实质上是把参数扔到了 OUTPUT_FLASH_MAP_ATTRIBUTE 中。</p><h2 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h2><p>当 IOC 容器初始化完成之后发布事件，触发事件监听调用到<code>org.springframework.web.servlet.DispatcherServlet#onRefresh</code><br>而这些组件是在这里初始化的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里大体的套路都是类似的。找一个进去看看就能明白大致的过程了。<br>org.springframework.web.servlet.DispatcherServlet#initHandlerMappings</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.handlerMappings = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line">		<span class="comment">// 从容器中拿到所有的HandlerMapping对象</span></span><br><span class="line">		Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">				BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line">			<span class="comment">// 按照order排序</span></span><br><span class="line">				AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 用固定的名称来找</span></span><br><span class="line">			HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			<span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">			<span class="comment">// Ignore, we'll add a default HandlerMapping later.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果上面没找到 走默认的</span></span><br><span class="line">	<span class="comment">// 默认的实际上就是读配置文件 DispatcherServlet.properties 中的配置进行加载的</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"No HandlerMappings declared for servlet '"</span> + getServletName() +</span><br><span class="line">					<span class="string">"': using default strategies from DispatcherServlet.properties"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.web.servlet.DispatcherServlet#initMultipartRes olver</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initMultipartResolver</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 这行代码可以说明为什么多文件解析器需要配置一个固定名称的bean,因为这里是写死的</span></span><br><span class="line">		<span class="keyword">this</span>.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Detected "</span> + <span class="keyword">this</span>.multipartResolver);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Detected "</span> + <span class="keyword">this</span>.multipartResolver.getClass().getSimpleName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">		<span class="keyword">this</span>.multipartResolver = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"No MultipartResolver '"</span> + MULTIPART_RESOLVER_BEAN_NAME + <span class="string">"' declared"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Spring AnnotationUtils</title>
    <url>/2020/10/10/Spring%20AnnotationUtils/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p><code>AnnotationUtils</code>是 spring 中用于处理复杂注解问题的工具类。</p><p>在看这类之前先看一下 java 中的一些接口概念</p><ul><li><code>Annotation</code>表示注解</li><li><code>AnnotatedElement</code> 表示被注解的元素，可以是 Class、Method、Filed 等，所有实现了这个接口的元素都可以是被注解的元素</li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h4 id="getAnnotation-从指定元素上获取指定注解"><a href="#getAnnotation-从指定元素上获取指定注解" class="headerlink" title="getAnnotation 从指定元素上获取指定注解"></a>getAnnotation 从指定元素上获取指定注解</h4><p>只查找本类的</p><p>getAnnotation 提供了三个重载接口<br><img src="/images/1602302078443-132c3945-401f-4c36-ac27-aefbdf8e1fa7.png" alt="image.png"><br>获取注解的的方式是通过反射。不过需要注意的是这些方法是<strong>支持注解嵌套</strong>的。比如说<code>@Service</code>上面有<code>@Component</code>注解。那么实际上 Spring 在用这个方法拿<code>@Component</code>的时候，带上<code>@Service</code>的也会被拿到。这样就实现了类似继承的效果了。</p><p>Spring 中的<code>@AliasFor</code>也是在这里<code>getAnnotation</code>这里处理的。实现方式是动态代理。</p><p><code>org.springframework.core.annotation.AnnotationUtils#synthesizeAnnotation(A, java.lang.Object)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">synthesizeAnnotation</span><span class="params">(A annotation, @Nullable Object annotatedElement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经被代理过了 或者是注解里面只有java语言的注解或者 org.springframework.lang包下面的扩展注解就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> SynthesizedAnnotation || hasPlainJavaAnnotationsOnly(annotatedElement)) &#123;</span><br><span class="line">        <span class="keyword">return</span> annotation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType = annotation.annotationType();</span><br><span class="line">    <span class="comment">// 判断是否需要被代理</span></span><br><span class="line">    <span class="keyword">if</span> (!isSynthesizable(annotationType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> annotation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DefaultAnnotationAttributeExtractor attributeExtractor =</span><br><span class="line">        <span class="keyword">new</span> DefaultAnnotationAttributeExtractor(annotation, annotatedElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造用于创建代理的Handler</span></span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> SynthesizedAnnotationInvocationHandler(attributeExtractor);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exposedInterfaces = <span class="keyword">new</span> Class&lt;?&gt;[] &#123;annotationType, SynthesizedAnnotation<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理</span></span><br><span class="line">    <span class="keyword">return</span> (A) Proxy.newProxyInstance(annotation.getClass().getClassLoader(), exposedInterfaces, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下判断是否需要被代理的<code>isSynthesizable</code>，这里主要判断 method 是否带有<code>@AliasFor</code>注解，或者返回值的注解的 method 带不带<code>@AliasFor</code>注解<br><code>org.springframework.core.annotation.AnnotationUtils#isSynthesizable</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSynthesizable</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注解里面只有java语言的注解或者 org.springframework.lang包下面的扩展注解 不需要代理</span></span><br><span class="line">    <span class="keyword">if</span> (hasPlainJavaAnnotationsOnly(annotationType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存中拿，如果已经判断过就直接返回了。</span></span><br><span class="line">    Boolean synthesizable = synthesizableCache.get(annotationType);</span><br><span class="line">    <span class="keyword">if</span> (synthesizable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> synthesizable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synthesizable = Boolean.FALSE;</span><br><span class="line">    <span class="comment">// 遍历注解里面的所有属性的method</span></span><br><span class="line">    <span class="comment">// 属性的method就是 没有参数，并且返回值不是void的method</span></span><br><span class="line">    <span class="keyword">for</span> (Method attribute : getAttributeMethods(annotationType)) &#123;</span><br><span class="line">        <span class="comment">// method上有@AliasFor</span></span><br><span class="line">        <span class="keyword">if</span> (!getAttributeAliasNames(attribute).isEmpty()) &#123;</span><br><span class="line">            synthesizable = Boolean.TRUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; returnType = attribute.getReturnType();</span><br><span class="line">        <span class="comment">// 返回值是注解数组</span></span><br><span class="line">        <span class="keyword">if</span> (Annotation[]<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">returnType</span>)) </span>&#123;</span><br><span class="line">            Class&lt;? extends Annotation&gt; nestedAnnotationType =</span><br><span class="line">                (Class&lt;? extends Annotation&gt;) returnType.getComponentType();</span><br><span class="line">            <span class="comment">// 递归判断</span></span><br><span class="line">            <span class="keyword">if</span> (isSynthesizable(nestedAnnotationType)) &#123;</span><br><span class="line">                synthesizable = Boolean.TRUE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回值类型是注解</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Annotation<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">returnType</span>)) </span>&#123;</span><br><span class="line">            Class&lt;? extends Annotation&gt; nestedAnnotationType = (Class&lt;? extends Annotation&gt;) returnType;</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="keyword">if</span> (isSynthesizable(nestedAnnotationType)) &#123;</span><br><span class="line">                synthesizable = Boolean.TRUE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果放进缓存</span></span><br><span class="line">    synthesizableCache.put(annotationType, synthesizable);</span><br><span class="line">    <span class="keyword">return</span> synthesizable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理实际上是获取了<code>@AliasFor</code>的值，放到了对应方法的返回值。<br>流程代码如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 处理 Annotation接口里面的自带方法</span></span><br><span class="line">    <span class="keyword">if</span> (ReflectionUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> annotationEquals(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ReflectionUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> annotationHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ReflectionUtils.isToStringMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> annotationToString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (AnnotationUtils.isAnnotationTypeMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> annotationType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常情况应该走不到这个if ，因为前面有判断</span></span><br><span class="line">    <span class="keyword">if</span> (!AnnotationUtils.isAttributeMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationConfigurationException(String.format(</span><br><span class="line">            <span class="string">"Method [%s] is unsupported for synthesized annotation type [%s]"</span>, method, annotationType()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回属性值</span></span><br><span class="line">    <span class="keyword">return</span> getAttributeValue(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getAttributeValue</span><span class="params">(Method attributeMethod)</span> </span>&#123;</span><br><span class="line">    String attributeName = attributeMethod.getName();</span><br><span class="line">    Object value = <span class="keyword">this</span>.valueCache.get(attributeName);</span><br><span class="line">    <span class="comment">// 缓存中没有</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取值。 把@AliasFor的值组装起来</span></span><br><span class="line">        value = <span class="keyword">this</span>.attributeExtractor.getAttributeValue(attributeMethod);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            String msg = String.format(<span class="string">"%s returned null for attribute name [%s] from attribute source [%s]"</span>,</span><br><span class="line">                                       <span class="keyword">this</span>.attributeExtractor.getClass().getName(), attributeName, <span class="keyword">this</span>.attributeExtractor.getSource());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注解 递归</span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Annotation) &#123;</span><br><span class="line">            value = AnnotationUtils.synthesizeAnnotation((Annotation) value, <span class="keyword">this</span>.attributeExtractor.getAnnotatedElement());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注解数组 递归</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Annotation[]) &#123;</span><br><span class="line">            value = AnnotationUtils.synthesizeAnnotationArray((Annotation[]) value, <span class="keyword">this</span>.attributeExtractor.getAnnotatedElement());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.valueCache.put(attributeName, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆结果。防止用户该值导致问题</span></span><br><span class="line">    <span class="keyword">if</span> (value.getClass().isArray()) &#123;</span><br><span class="line">        value = cloneArray(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getAnnotations-获取被注解的元素或者方法上的全部注解"><a href="#getAnnotations-获取被注解的元素或者方法上的全部注解" class="headerlink" title="getAnnotations 获取被注解的元素或者方法上的全部注解"></a>getAnnotations 获取被注解的元素或者方法上的全部注解</h4><p>和上面基本一样，循环调用<code>synthesizeAnnotation</code>实现的。</p><h4 id="getRepeatableAnnotations-获取重复的注解"><a href="#getRepeatableAnnotations-获取重复的注解" class="headerlink" title="getRepeatableAnnotations 获取重复的注解"></a>getRepeatableAnnotations 获取重复的注解</h4><p>把要查找的注解全部都都查出来，以 Set 的形式返回。<br>这里的可重复注解包括：</p><ul><li>注解上的注解</li><li>java 元素上的注解</li><li>注解里有注解的</li></ul><h4 id="findAnnotation-查找注解"><a href="#findAnnotation-查找注解" class="headerlink" title="findAnnotation 查找注解"></a>findAnnotation 查找注解</h4><p>findAnnotation 查找顺序式本类、本类的注解、父接口、父类、父类的接口。。。<br>和<code>getRepeatableAnnotations</code>不一样的地方是，这个找到一个直接返回</p><h4 id="getAnnotationAttributes-把注解属性转换成-map-返回"><a href="#getAnnotationAttributes-把注解属性转换成-map-返回" class="headerlink" title="getAnnotationAttributes 把注解属性转换成 map 返回"></a>getAnnotationAttributes 把注解属性转换成 map 返回</h4><p>该方法由多个重载。有的直接返回 map，有的返回<code>AnnoationAttributes</code>，是 map 的一个子类。<br><img src="/images/1602589998772-5f416745-969b-4b0c-b497-773795f40242.png" alt="image.png"><br>然后就可以通过 get 从 map 中获取属性值了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.code260.com/2020/07/11/spring-01-01.utils-annotation/" target="_blank" rel="noopener">http://www.code260.com/2020/07/11/spring-01-01.utils-annotation/</a></p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Sping 声明式事物控制流程</title>
    <url>/2020/10/07/Sping%20%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E7%89%A9%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>spring 的声明式事物是基于 aop 实现的。本质是对方法前后进行拦截，在目标方法开始之前创建或者加入一个事物，在方法之后根据执行情况提交或者回滚事物。</p><p>aop 是通过 bean 的生命周期<code>BeanPostProcessor</code>中的<code>postProcessAfterInitialization</code>中创建的动态代理实现的这里就不展开了。</p><p><code>org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTransactionManagementConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractTransactionManagementConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span>(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span><br><span class="line">	<span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    <span class="comment">// 定义事物增强器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="title">transactionAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义advisor</span></span><br><span class="line">		BeanFactoryTransactionAttributeSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryTransactionAttributeSourceAdvisor();</span><br><span class="line">		<span class="comment">// 设置事物属性</span></span><br><span class="line">        advisor.setTransactionAttributeSource(transactionAttributeSource());</span><br><span class="line">        <span class="comment">// 设置事物拦截器</span></span><br><span class="line">		advisor.setAdvice(transactionInterceptor());</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.enableTx != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 顺序</span></span><br><span class="line">			advisor.setOrder(<span class="keyword">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="string">"order"</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> advisor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    <span class="comment">// 定义基于注解的事物属性资源</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TransactionAttributeSource <span class="title">transactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AnnotationTransactionAttributeSource();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    <span class="comment">// 定义事物拦截器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TransactionInterceptor <span class="title">transactionInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		TransactionInterceptor interceptor = <span class="keyword">new</span> TransactionInterceptor();</span><br><span class="line">		interceptor.setTransactionAttributeSource(transactionAttributeSource());</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.txManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">			interceptor.setTransactionManager(<span class="keyword">this</span>.txManager);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> interceptor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心的拦截器就是下面的<code>transactionInterceptor()</code>方法返回的<code>TransactionInterceptor</code><br>该类继承了<code>TransactionAspectSupport</code>（该类包含了 spring 的底层事物 api 的集成）实现了<code>org.aopalliance.intercept.MethodInterceptor</code>接口。<br>主要来看一下 invoke 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// Work out the target class: may be &#123;@code null&#125;.</span></span><br><span class="line">    <span class="comment">// The TransactionAttributeSource should be passed the target class</span></span><br><span class="line">    <span class="comment">// as well as the method, which may be from an interface.</span></span><br><span class="line">    Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用夫类（TransactionAspectSupport）的invokeWithinTransaction方法</span></span><br><span class="line">    <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果transaction attribute为空，则该方法是非编程式事物</span></span><br><span class="line">    TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">    <span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">    <span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">        <span class="comment">// 标准声明式事物</span></span><br><span class="line">        TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行方法</span></span><br><span class="line">            retVal = invocation.proceedWithInvocation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// 异常回滚</span></span><br><span class="line">            completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清空当前事物信息，重置为老的</span></span><br><span class="line">            cleanupTransactionInfo(txInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果之前提交事物</span></span><br><span class="line">        commitTransactionAfterReturning(txInfo);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 编程式事物 （回调）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ThrowableHolder throwableHolder = <span class="keyword">new</span> ThrowableHolder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr, status -&gt; &#123;</span><br><span class="line">                TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> invocation.proceedWithInvocation();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (txAttr.rollbackOn(ex)) &#123;</span><br><span class="line">                        <span class="comment">// 异常回滚</span></span><br><span class="line">                        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ThrowableHolderException(ex);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 不需要回滚的异常</span></span><br><span class="line">                        throwableHolder.throwable = ex;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 清空当前事物信息，重置为老的</span></span><br><span class="line">                    cleanupTransactionInfo(txInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 上抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (throwableHolder.throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> throwableHolder.throwable;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ThrowableHolderException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.getCause();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (throwableHolder.throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">"Application exception overridden by commit exception"</span>, throwableHolder.throwable);</span><br><span class="line">                ex2.initApplicationException(throwableHolder.throwable);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (throwableHolder.throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">"Application exception overridden by commit exception"</span>, throwableHolder.throwable);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有必要则创建事务<br><code>org.springframework.transaction.interceptor.TransactionAspectSupport#createTransactionIfNecessary</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(@Nullable PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       @Nullable TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还没定义名字 把连接点的ID定义成事务的名称</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用 org.springframework.transaction.support.AbstractPlatformTransactionManager#getTransaction</span></span><br><span class="line">            status = tm.getTransaction(txAttr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Skipping transactional joinpoint ["</span> + joinpointIdentification +</span><br><span class="line">                             <span class="string">"] because no transaction manager has been configured"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个TransactionInfo事务信息对象，绑定到当前线程</span></span><br><span class="line">    <span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下 <code>org.springframework.transaction.support.AbstractPlatformTransactionManager#getTransaction</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    Object transaction = doGetTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache debug flag to avoid repeated checks.</span></span><br><span class="line">    <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (definition == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">        definition = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前已经存在事务</span></span><br><span class="line">    <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">        <span class="comment">// 根据不同的传播机制不同处理</span></span><br><span class="line">        <span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验事务的超时时间不能小于默认值</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">"Invalid transaction timeout"</span>, definition.getTimeout());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前不能存事务，传播机制是 PROPAGATION_MANDATORY（支持当前事务，没事务报错） 报错。</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">            <span class="string">"No existing transaction found for transaction marked with propagation 'mandatory'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">             definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">             definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">        SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Creating new transaction with name ["</span> + definition.getName() + <span class="string">"]: "</span> + definition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 是否需要新开启同步</span></span><br><span class="line">            <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">            DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">                definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">            <span class="comment">// 开新的事务</span></span><br><span class="line">            doBegin(transaction, definition);</span><br><span class="line">            <span class="comment">// 准备同步</span></span><br><span class="line">            prepareSynchronization(status, definition);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前不存在事务，并且传播机制不是ISOLATION_DEFAULT 创建空事务，没有实际的事物，单可能是同步</span></span><br><span class="line">        <span class="comment">// 定义了隔离级别单并没有事务初始化，隔离级别被忽略</span></span><br><span class="line">        <span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Custom isolation level specified but no actual transaction initiated; "</span> +</span><br><span class="line">                        <span class="string">"isolation level will effectively be ignored: "</span> + definition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">        <span class="keyword">return</span> prepareTransactionStatus(definition, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面有一步如果有事务，就根据不同的传播机制不同处理。来看一下<br><code>org.springframework.transaction.support.AbstractPlatformTransactionManager#handleExistingTransaction</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">handleExistingTransaction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    TransactionDefinition definition, Object transaction, <span class="keyword">boolean</span> debugEnabled)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PROPAGATION_NEVER 不支持当前事务，如果当前有事务就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">            <span class="string">"Existing transaction found for transaction marked with propagation 'never'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PROPAGATION_NOT_SUPPORTED 不支持当前事务，现有同步将被挂起，挂起当前事务</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Suspending current transaction"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object suspendedResources = suspend(transaction);</span><br><span class="line">        <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">        <span class="keyword">return</span> prepareTransactionStatus(</span><br><span class="line">            definition, <span class="keyword">null</span>, <span class="keyword">false</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PROPAGATION_REQUIRES_NEW 挂起当前事务，创建新事务</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Suspending current transaction, creating new transaction with name ["</span> +</span><br><span class="line">                         definition.getName() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 挂起当前事务</span></span><br><span class="line">        SuspendedResourcesHolder suspendedResources = suspend(transaction);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建新事物</span></span><br><span class="line">            <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">            DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">                definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">            doBegin(transaction, definition);</span><br><span class="line">            prepareSynchronization(status, definition);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | Error beginEx) &#123;</span><br><span class="line">            resumeAfterBeginException(transaction, suspendedResources, beginEx);</span><br><span class="line">            <span class="keyword">throw</span> beginEx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的事务</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isNestedTransactionAllowed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NestedTransactionNotSupportedException(</span><br><span class="line">                <span class="string">"Transaction manager does not allow nested transactions by default - "</span> +</span><br><span class="line">                <span class="string">"specify 'nestedTransactionAllowed' property with value 'true'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Creating nested transaction with name ["</span> + definition.getName() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否支持保存节点</span></span><br><span class="line">        <span class="keyword">if</span> (useSavepointForNestedTransaction()) &#123;</span><br><span class="line">            <span class="comment">// Create savepoint within existing Spring-managed transaction,</span></span><br><span class="line">            <span class="comment">// through the SavepointManager API implemented by TransactionStatus.</span></span><br><span class="line">            <span class="comment">// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.</span></span><br><span class="line">            DefaultTransactionStatus status =</span><br><span class="line">                prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, <span class="keyword">false</span>, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 创建保存节点</span></span><br><span class="line">            status.createAndHoldSavepoint();</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// jta事务走这个分支 创建新事务</span></span><br><span class="line">            <span class="comment">// Nested transaction through nested begin and commit/rollback calls.</span></span><br><span class="line">            <span class="comment">// Usually only for JTA: Spring synchronization might get activated here</span></span><br><span class="line">            <span class="comment">// in case of a pre-existing JTA transaction.</span></span><br><span class="line">            <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">            DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">                definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">            doBegin(transaction, definition);</span><br><span class="line">            prepareSynchronization(status, definition);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.</span></span><br><span class="line">    <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Participating in existing transaction"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isValidateExistingTransaction()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123;</span><br><span class="line">            Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">            <span class="keyword">if</span> (currentIsolationLevel == <span class="keyword">null</span> || currentIsolationLevel != definition.getIsolationLevel()) &#123;</span><br><span class="line">                Constants isoConstants = DefaultTransactionDefinition.constants;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(<span class="string">"Participating transaction with definition ["</span> +</span><br><span class="line">                                                           definition + <span class="string">"] specifies isolation level which is incompatible with existing transaction: "</span> +</span><br><span class="line">                                                           (currentIsolationLevel != <span class="keyword">null</span> ?</span><br><span class="line">                                                            isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :</span><br><span class="line">                                                            <span class="string">"(unknown)"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!definition.isReadOnly()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(<span class="string">"Participating transaction with definition ["</span> +</span><br><span class="line">                                                           definition + <span class="string">"] is not marked as read-only but existing transaction is"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非SYNCHRONIZATION_NEVER 存在事务则加入事务</span></span><br><span class="line">    <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">    <span class="keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里平时用的一般都是默认配置，走的是创建新事务那个节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">    Connection con = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果事物还没有connection或者connection在事物同步状态，重置connectonHoleder</span></span><br><span class="line">        <span class="keyword">if</span> (!txObject.hasConnectionHolder() ||</span><br><span class="line">            txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">            Connection newCon = obtainDataSource().getConnection();</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Acquired Connection ["</span> + newCon + <span class="string">"] for JDBC transaction"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            txObject.setConnectionHolder(<span class="keyword">new</span> ConnectionHolder(newCon), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置新的连接为事物同步中</span></span><br><span class="line">        txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="keyword">true</span>);</span><br><span class="line">        con = txObject.getConnectionHolder().getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置只读的事物隔离级别</span></span><br><span class="line">        Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line">        txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是自动提交，切换到手动提交</span></span><br><span class="line">        <span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">            txObject.setMustRestoreAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Switching JDBC Connection ["</span> + con + <span class="string">"] to manual commit"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            con.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是只读，执行sql设置事物只读</span></span><br><span class="line">        prepareTransactionalConnection(con, definition);</span><br><span class="line">        <span class="comment">// 设置connection持有者的事物开启状态</span></span><br><span class="line">        txObject.getConnectionHolder().setTransactionActive(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> timeout = determineTimeout(definition);</span><br><span class="line">        <span class="keyword">if</span> (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">            <span class="comment">// 超时时间</span></span><br><span class="line">            txObject.getConnectionHolder().setTimeoutInSeconds(timeout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定connectionHolder到当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">            TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">            DataSourceUtils.releaseConnection(con, obtainDataSource());</span><br><span class="line">            txObject.setConnectionHolder(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CannotCreateTransactionException(<span class="string">"Could not open JDBC Connection for transaction"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Spring AOP代理对象创建流程</title>
    <url>/2020/10/06/Spring%20AOP%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>Spring AOP 生成对象的时机是使用了 Spring 生命周期里面的<code>BeanPostProcessor</code>中的<code>postProcessAfterInitialization</code>实现的。</p><p><code>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessAfterInitialization</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#wrapIfNecessary</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 	...</span></span><br><span class="line"><span class="comment">// 找当前的bean是否有匹配的advice</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">    <span class="comment">// 标记增强为true，表示需要增强实现</span></span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">    <span class="comment">// 创建代理</span></span><br><span class="line">    Object proxy = createProxy(</span><br><span class="line">        bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">    <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><code>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#createProxy</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">                             @Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理工作交给ProxyFactory</span></span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否强制使用cglib代理</span></span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把增强和通用拦截器对象合并，都适配成Advisor</span></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备工作完成，开始创建动态代理</span></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.aop.framework.ProxyFactory#getProxy(java.lang.ClassLoader)</code><br>这里又封装了一层 aopProxy<br><code>org.springframework.aop.framework.DefaultAopProxyFactory#createAopProxy</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="comment">// 优化 强制开启cglib代理 没有接口</span></span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">                                         <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接口 或者本身是jdl代理产生的</span></span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用jdk动态代理</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Spring IOC 循环依赖问题</title>
    <url>/2020/10/06/Spring%20IOC%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><h2 id="Spring-中的循环依赖场景"><a href="#Spring-中的循环依赖场景" class="headerlink" title="Spring 中的循环依赖场景"></a>Spring 中的循环依赖场景</h2><ul><li>构造函数注入循环依赖</li><li>Filed 属性循环依赖</li></ul><h2 id="循环依赖处理机制"><a href="#循环依赖处理机制" class="headerlink" title="循环依赖处理机制"></a>循环依赖处理机制</h2><h3 id="单例-bean-的构造函数注入的循环依赖是无法解决的"><a href="#单例-bean-的构造函数注入的循环依赖是无法解决的" class="headerlink" title="单例 bean 的构造函数注入的循环依赖是无法解决的"></a>单例 bean 的构造函数注入的循环依赖是无法解决的</h3><h3 id="prototype-的循环依赖无法解决的"><a href="#prototype-的循环依赖无法解决的" class="headerlink" title="prototype 的循环依赖无法解决的"></a>prototype 的循环依赖无法解决的</h3><p>原型 bean 的初始化过程不论是构造函数注入还是 set 方法注入，产生循环依赖 spring 都会直接报错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.beans.factory.support.AbstractBeanFactory#isPrototypeCurrentlyInCreation</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isPrototypeCurrentlyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">    Object curVal = <span class="keyword">this</span>.prototypesCurrentlyInCreation.get();</span><br><span class="line">    <span class="keyword">return</span> (curVal != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (curVal.equals(beanName) || (curVal <span class="keyword">instanceof</span> Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取 bean 之前，如果这个原型 bean 正在被创建，则直接抛出异常。原型 bean 在创建之前会标记这个 beanName 正在被创建，等待创建结束之后会删除标记。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建前添加标记</span></span><br><span class="line">    beforePrototypeCreation(beanName);</span><br><span class="line">    <span class="comment">// 创建bean</span></span><br><span class="line">    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 删除标记</span></span><br><span class="line">    afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例-bean-通过-setXxx-或者-Autowired-进行循环依赖的"><a href="#单例-bean-通过-setXxx-或者-Autowired-进行循环依赖的" class="headerlink" title="单例 bean 通过 setXxx 或者@Autowired 进行循环依赖的"></a>单例 bean 通过 setXxx 或者@Autowired 进行循环依赖的</h3><p>三级缓存机制解决循环依赖<br>一级缓存<code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonObjects</code><br>二级缓存<code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#earlySingletonObjects</code><br>三级缓存<code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonFactories</code></p><p>实例化 bean 之后会先丢到三级缓存中去<br><code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                  isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                     <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入三级缓存中</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从一级缓存中拿</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 从二级缓存中拿</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="comment">// 从三级缓存中拿</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 调用当时丢到三级缓存中传入的接口</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">// 丢掉二级缓存中</span></span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="comment">// 从三级缓存中拿出去</span></span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从二级缓存丢到一级缓存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">        <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">        <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Spring IOC容器初始化流程</title>
    <url>/2020/10/05/Spring%20IOC%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p><code>BeanFactory</code>是 IOC 容器的顶级接口规范和定义了容器的基础行为。<br><code>ApplicationContext</code>继承自<code>BeanFactory</code>。Spring 应用上下文，官方称之为 IOC 容器。</p><p>发现了一个现象，spring 的源码中嵌套层次很多，但是真正干活的方法一般是 doXXX。</p><h2 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h2><p><code>org.springframework.context.support.AbstractApplicationContext#refresh</code><br>进来之后先加了个对象锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/1601881489992-82a6c437-22a4-4e16-bbe2-1b58b729e881.png" alt="image.png"><br>这三个方法不能同时进行。</p><h4 id="1-prepareRefresh"><a href="#1-prepareRefresh" class="headerlink" title="1. prepareRefresh"></a>1. prepareRefresh</h4><p>然后进入准备工作的方法<br><code>org.springframework.context.support.AbstractApplicationContext#prepareRefresh</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化启动时间呢活动标志</span></span><br><span class="line">	<span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">	<span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			 logger.debug(<span class="string">"Refreshing "</span> + getDisplayName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化属性资源。默认是空。子类扩展</span></span><br><span class="line">	initPropertySources();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 环境变量校验</span></span><br><span class="line">	getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 容器启动之前监听器</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">		<span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-obtainFreshBeanFactory"><a href="#2-obtainFreshBeanFactory" class="headerlink" title="2. obtainFreshBeanFactory"></a>2. obtainFreshBeanFactory</h4><ol><li>创建 beanFactory</li></ol><p><code>org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否有beanFactory，有则清除</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建beanFactory</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        <span class="comment">// 设置序列化id</span></span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        <span class="comment">// 自定义bean工厂的一些属性（是否覆盖、是否允许循环依赖）</span></span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// 加载应用中的BeanDefinitions</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>读取 bean 并封装成<code>BeanDefnition</code>并注册到<code>BeanDefnitionRegistry</code></li></ol><h5 id="xml-方式"><a href="#xml-方式" class="headerlink" title="xml 方式"></a>xml 方式</h5><h5 id="org-springframework-context-support-AbstractXmlApplicationContext-loadBeanDefinitions"><a href="#org-springframework-context-support-AbstractXmlApplicationContext-loadBeanDefinitions" class="headerlink" title="org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions"></a><code>org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions</code></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建xml读取器</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给读取器设置一些属性</span></span><br><span class="line">    beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供给子类实现提供的一些自定义策略</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载BeanDefinitions</span></span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.xml.XmlBeanDefinitionReader)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 从Resource资源对象加载BeanDefinitions</span></span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从xml配置文件加载BeanDefinition对象</span></span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.beans.factory.support.AbstractBeanDefinitionReader#loadBeanDefinitions(java.lang.String, java.util.Set&lt;org.springframework.core.io.Resource&gt;)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, @Nullable Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取上下文资源加载器</span></span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">"Cannot load bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断资源加载器是否 ResourcePatternResolver类型 （xml、url等不同类型统一接口为匹配类型）</span></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 统一加载转换为Resource资源对象</span></span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            <span class="comment">// 加载资源配置中的BeanDefinition对象，并返回数量</span></span><br><span class="line">            <span class="keyword">int</span> count = loadBeanDefinitions(resources);</span><br><span class="line">            <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Collections.addAll(actualResources, resources);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"Loaded "</span> + count + <span class="string">" bean definitions from location pattern ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        <span class="keyword">int</span> count = loadBeanDefinitions(resource);</span><br><span class="line">        <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Loaded "</span> + count + <span class="string">" bean definitions from location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一直往下找，直到<br><code>org.springframework.beans.factory.xml.XmlBeanDefinitionReader#doLoadBeanDefinitions</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取xml到Document对象</span></span><br><span class="line">Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="comment">// 解析document对象，封装BeanDefinition对象并进行注册</span></span><br><span class="line"><span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br></pre></td></tr></table></figure><p><code>org.springframework.beans.factory.xml.XmlBeanDefinitionReader#registerBeanDefinitions</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="comment">// 获取已有的BeanDefinition数量</span></span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    <span class="comment">// 注册BeanDefinition</span></span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="comment">// 返回新注册的数量</span></span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后往下往下走，直到<br><code>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#parseBeanDefinitions</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    <span class="comment">// 解析默认标签元素</span></span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 解析自定义标签元素</span></span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#parseDefaultElement</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">        <span class="comment">// import标签</span></span><br><span class="line">        importBeanDefinitionResource(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">        <span class="comment">// alias标签</span></span><br><span class="line">        processAliasRegistration(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">        <span class="comment">// bean标签</span></span><br><span class="line">        processBeanDefinition(ele, delegate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">        <span class="comment">// 嵌套beans处理</span></span><br><span class="line">        doRegisterBeanDefinitions(ele);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#processBeanDefinition</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析BeanDefinition。用BeanDefinitionHolder包装了一下</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 完成BeanDefinition注册</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">                                     bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后往往下找直到<br><code>org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br></pre></td></tr></table></figure><p>完成 bean 的注册</p><h4 id="3-prepareBeanFactory"><a href="#3-prepareBeanFactory" class="headerlink" title="3. prepareBeanFactory"></a>3. prepareBeanFactory</h4><p>前置处理。做一些初始化的工作</p><h4 id="4-postProcessBeanFactory"><a href="#4-postProcessBeanFactory" class="headerlink" title="4. postProcessBeanFactory"></a>4. postProcessBeanFactory</h4><p>后置处理，默认为空</p><h4 id="5-invokeBeanFactoryPostProcessors"><a href="#5-invokeBeanFactoryPostProcessors" class="headerlink" title="5. invokeBeanFactoryPostProcessors"></a>5. invokeBeanFactoryPostProcessors</h4><p>实例化实现了<code>BeanFactoryPostProcessor</code>接口 bean。并且调用实现的接口方法</p><h4 id="6-registerBeanPostProcessors"><a href="#6-registerBeanPostProcessors" class="headerlink" title="6. registerBeanPostProcessors"></a>6. registerBeanPostProcessors</h4><p>注册 BeanPostProcessor(Bean 的后置处理器)</p><h4 id="7-initMessageSource"><a href="#7-initMessageSource" class="headerlink" title="7. initMessageSource"></a>7. initMessageSource</h4><p>初始化 MessageSource 组件（国际化功能；消息绑定，消息解析）</p><h4 id="8-initApplicationEventMulticaster"><a href="#8-initApplicationEventMulticaster" class="headerlink" title="8. initApplicationEventMulticaster"></a>8. initApplicationEventMulticaster</h4><p>初始化事件的派发器</p><h4 id="9-onRefresh"><a href="#9-onRefresh" class="headerlink" title="9. onRefresh"></a>9. onRefresh</h4><p>空方法，子类重写这个方法，在容器刷新的时候可以自定义逻辑</p><h4 id="10-registerListeners"><a href="#10-registerListeners" class="headerlink" title="10 registerListeners"></a>10 registerListeners</h4><p>注册监听器，就是注册实现了<code>ApplocationListener</code>接口的监听器的 bean</p><h4 id="11-finishBeanFactoryInitialization"><a href="#11-finishBeanFactoryInitialization" class="headerlink" title="11 finishBeanFactoryInitialization"></a>11 finishBeanFactoryInitialization</h4><p>初始化剩下的非懒加载的单例 bean<br>初始化搜有非懒加载方式的单例 bean。未设置属性<br>填充属性<br>初始化方法的调用 afterPropertiesSet、initMethod<br>调用 BeanPostProcessor 后置处理器对实例 bean 进行后置处理</p><p>流程如下<br><code>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有bean的名字</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发所有非延迟加载的单例bean的初始化</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="comment">// 合并父BeanDefinition对象</span></span><br><span class="line">        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                <span class="comment">// Factorybean 加上 &amp;</span></span><br><span class="line">                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                    <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                    <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                        isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                                                                    ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                                                                    getAccessControlContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                                       ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                        getBean(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        Object singletonInstance = getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">            <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">                          @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取beanName 如果是工厂FactoryBean去掉&amp;，如果是别名，获取真正的名字</span></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从缓存中拿</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">                             <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 针对FactoryBean的处理</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是prototype类型 且开启允许循环依赖，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查夫工厂中是否有该对象</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                    nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            <span class="comment">// 标记一下</span></span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 合并父子bean的属性</span></span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理dependsOn</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                        <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                        <span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建单例bean</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 创建bean</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                        <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">finally</span> &#123;</span><br><span class="line">                            afterPrototypeCreation(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                                    <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">                                                    <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">                                                    ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">            <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> convertedBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">                             ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory&lt;?&gt;)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 是否正在销毁， 异常</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">                                                          <span class="string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +</span><br><span class="line">                                                          <span class="string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 验证完要真正开始创建对象，先标识该bean正在被创建</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用传进来的接口，就是上面传进来的createBean的那个接口</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">                <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">                singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">                        ex.addRelatedCause(suppressedException);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// BeanDefnition</span></span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取类信息</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare method overrides.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                                               beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                                        <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 真正的去创建bean</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">        <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 实例化bean，只调用了构造方法，未设置属性</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                                <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                         <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// bean填充属性</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 调用初始化方法，应用BeanPostProcessor后置处理器</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                                                               <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                                                               StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                                               <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                                                               <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                                                               <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                                                               <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean(java.lang.String, java.lang.Object, org.springframework.beans.factory.support.RootBeanDefinition)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;, getAccessControlContext());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 调用Aware接口的方法 BeanNameAware BeanClassLoaderAware BeanFactoryAware</span></span><br><span class="line">		invokeAwareMethods(beanName, bean);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Object wrappedBean = bean;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 执行初始化方法的调用 InitializingBean</span></span><br><span class="line">		invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">				beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// BeanPostProcessors 调用after方法</span></span><br><span class="line">		wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-finishRefresh"><a href="#12-finishRefresh" class="headerlink" title="12 finishRefresh"></a>12 finishRefresh</h4><p>完成 context 的刷新，主要调用<code>LifecycleProcessor</code>的 onRefresh 方法，并且发布 ContextRefreshedEvent</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Spring bean生命周期</title>
    <url>/2020/10/03/Spring%20bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p><img src="/images/82b97b15af648eddf5667da2dd5df62e.svg" alt=""></p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>mybatis mapper代理方式流程</title>
    <url>/2020/10/01/mybatis%20mapper%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>mapper 代理方式的本质就是动态代理。</p><p>在解析 xml 的时候对 mapper 标签进行解析<br><code>org.apache.ibatis.builder.xml.XMLConfigBuilder#mapperElement</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="comment">// 如果是package的方式配置</span></span><br><span class="line">        String mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">        String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">        String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">          InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个<code>if-esle</code>，对用着 mybatis 的两种<code>mapper</code>配置。这里我们来看<code>package</code>的这种配置方式。</p><p>一直往下找到<code>org.apache.ibatis.binding.MapperRegistry#addMappers(java.lang.String, java.lang.Class&lt;?&gt;)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappers</span><span class="params">(String packageName, Class&lt;?&gt; superType)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用工具类扫包下面的所有class</span></span><br><span class="line">  ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = <span class="keyword">new</span> ResolverUtil&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">  resolverUtil.find(<span class="keyword">new</span> ResolverUtil.IsA(superType), packageName);</span><br><span class="line">  Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses();</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; mapperClass : mapperSet) &#123;</span><br><span class="line">    addMapper(mapperClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用工具类扫包下面的所有 class，然后对每个 class，调用<code>org.apache.ibatis.binding.MapperRegistry#addMapper</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// mapper必须是接口</span></span><br><span class="line">  <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">    <span class="comment">// 只加载一次</span></span><br><span class="line">    <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;T&gt;(type));</span><br><span class="line">      <span class="comment">// 解析mapper上的注解</span></span><br><span class="line">      MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">      parser.parse();</span><br><span class="line">      loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">        knownMappers.remove(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>addMapper</code>这里会把当前接口添加到<code>knownMappers</code>中。这是一个 key 是接口类型，value 是<code>MapperProxyFactory</code>的 map。<br>再来看下什么时候会用到这个 map。<br>在使用<code>org.apache.ibatis.session.defaults.DefaultSqlSession#getMapper</code>获取 mapper 接口的时候。一直往下找，直到<br><code>org.apache.ibatis.binding.MapperRegistry#getMapper</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">  <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会从刚才的 map 中把<code>MapperProxyFactory</code>掏出来，然后调用<code>newInstance</code>方法生成返回值。<br>再来看一下<code>newInstance</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 新建一个MapperProxy</span></span><br><span class="line">  <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">  <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回jdk动态代理的对象。</span></span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下<code>MapperProxy</code>这个类。这个类实现了 jdk 动态代理的<code>InvocationHandler</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">      <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">  <span class="comment">// 执行方法</span></span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在<code>org.apache.ibatis.binding.MapperMethod#execute</code>中调用 sqlSession 的方法，完成调用。</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>mybatis执行sql流程</title>
    <url>/2020/10/01/mybatis%E6%89%A7%E8%A1%8Csql%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><p><code>org.apache.ibatis.session.SqlSession</code>是一个接口。在 mybatis 中有两个实现类<br><img src="/images/1601551497204-0768fd64-b574-4b47-a49d-a4fbea572994.png" alt="image.png"><br>下文分析的代码是默认的实现类`org.apache.ibatis.session.defaults.DefaultSqlSession```</p><p><code>SqlSession</code>是 mybatis 用于和数据库交互的顶层类，通常将它于<code>ThreadLocal</code>绑定，一个会话使用一个<code>SqlSession</code>线程不安全，在使用完毕需要 close。</p><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p><code>org.apache.ibatis.executor.Executor</code>是<code>SqlSession</code>中的一个属性，<code>SqlSession</code>在实际执行的过程中把命令委托给<code>Executor</code>。<br><code>Executor</code>是一个接口，有三个常用的实现类</p><ul><li><code>org.apache.ibatis.executor.BatchExecutor</code>重用语句，并执行批量更新</li><li><code>org.apache.ibatis.executor.ReuseExecutor</code>重用预处理语句 prepared statements</li><li><code>org.apache.ibatis.executor.SimpleExecutor</code>普通执行器，默认</li></ul><h2 id="执行-sql"><a href="#执行-sql" class="headerlink" title="执行 sql"></a>执行 sql</h2><p>获取<code>sqlSession</code><br><code>org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSessionFromDataSource</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ExecutorType Executor的类型，类型对应着上面提到的三个实现类，这里外面传过来的是simple</span></span><br><span class="line">  <span class="comment">// TransactionIsolationLevel 事物隔离级别</span></span><br><span class="line">  <span class="comment">// autoCommit 是否自动提交事物</span></span><br><span class="line">  Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 运行环境</span></span><br><span class="line">    <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">    <span class="comment">// 事物</span></span><br><span class="line">    <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">    <span class="comment">// 初始化Executor，因为上面传来的type是simple，这里实际上生成的是SimpleExecutor</span></span><br><span class="line">    <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">    <span class="comment">// 生产DefaultSqlSession</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到<code>sqlSession</code>之后就可以使用<code>sqlSession</code>的 api 了</p><p><code>org.apache.ibatis.session.defaults.DefaultSqlSession#selectList(java.lang.String, java.lang.Object, org.apache.ibatis.session.RowBounds)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 根据传过来的statementId 获取MappedStatement对象，这个对象封装了sql语句</span></span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="comment">// 执行查询操作。实际上是executor执行的</span></span><br><span class="line">    <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h3><p><code>org.apache.ibatis.executor.BaseExecutor#query(org.apache.ibatis.mapping.MappedStatement, java.lang.Object, org.apache.ibatis.session.RowBounds, org.apache.ibatis.session.ResultHandler)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="comment">// 根据传入参数动态获取sql</span></span><br><span class="line">   BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">   <span class="comment">// 创建本次查询的缓存key</span></span><br><span class="line">   CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">   <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.apache.ibatis.executor.BaseExecutor#query(org.apache.ibatis.mapping.MappedStatement, java.lang.Object, org.apache.ibatis.session.RowBounds, org.apache.ibatis.session.ResultHandler, org.apache.ibatis.cache.CacheKey, org.apache.ibatis.mapping.BoundSql)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span><br><span class="line">  <span class="comment">// 执行器是否被关闭</span></span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">    <span class="comment">// 从一级缓存中获取查询结果</span></span><br><span class="line">    list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 查不到，从数据库中查</span></span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    deferredLoads.clear();</span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.apache.ibatis.executor.BaseExecutor#queryFromDatabase</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="comment">// 添加占位对象，这个跟延迟加载有关。org.apache.ibatis.executor.BaseExecutor.DeferredLoad#canLoad</span></span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 移除占位对象</span></span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加到一级缓存中</span></span><br><span class="line">  localCache.putObject(key, list);</span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.apache.ibatis.executor.SimpleExecutor#doQuery</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Configuration configuration = ms.getConfiguration();</span><br><span class="line">  <span class="comment">// 创建StatementHandler对象来执行查询</span></span><br><span class="line">  StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  <span class="comment">// 创建组装statement对象</span></span><br><span class="line">  stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">  <span class="comment">// 执行操作</span></span><br><span class="line">  <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  closeStatement(stmt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h3><p>设置参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 真正设置参数的是parameterHandler</span></span><br><span class="line">  parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.apache.ibatis.scripting.defaults.DefaultParameterHandler#setParameters</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">"setting parameters"</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">      <span class="comment">// 获取parameterMapping</span></span><br><span class="line">      ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">      <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        <span class="comment">// 获取name，根据name获取值</span></span><br><span class="line">        Object value;</span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">          value = metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取TypeHandler 负责jdbcType和javaType之间的类型转换</span></span><br><span class="line">        TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">        JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">          jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置？占位符的参数</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TypeException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not set parameters for mapping: "</span> + parameterMapping + <span class="string">". Cause: "</span> + e, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not set parameters for mapping: "</span> + parameterMapping + <span class="string">". Cause: "</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.apache.ibatis.executor.statement.PreparedStatementHandler#query</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 执行查询</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="comment">// 处理结果</span></span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);zh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.apache.ibatis.executor.resultset.DefaultResultSetHandler#handleResultSets</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">"handling results"</span>).object(mappedStatement.getId());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 多ResultdSet的结果集合，每个ResultSet对应一个Object对象。而实际上，每个Object都是List&lt;Object&gt;对象</span></span><br><span class="line">  <span class="comment">// 在不考虑存储过程中的多ResultdSet的情况，普通查询就有一个ResultdSet</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 获取首个ResultdSet并封装成ResultSetWrapper</span></span><br><span class="line">  ResultSetWrapper rsw = getFirstResultSet(stmt);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取resultMaps</span></span><br><span class="line">  List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">  <span class="keyword">int</span> resultMapCount = resultMaps.size();</span><br><span class="line">  <span class="comment">// 校验</span></span><br><span class="line">  validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">  <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">    <span class="comment">// 获取ResultMap</span></span><br><span class="line">    ResultMap resultMap = resultMaps.get(resultSetCount);</span><br><span class="line">    <span class="comment">// 处理ResultSet 将结果放入multipleResults</span></span><br><span class="line">    handleResultSet(rsw, resultMap, multipleResults, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 获取下一个</span></span><br><span class="line">    rsw = getNextResultSet(stmt);</span><br><span class="line">    cleanUpAfterHandlingResultSet();</span><br><span class="line">    resultSetCount++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储过程中使用</span></span><br><span class="line">  String[] resultSets = mappedStatement.getResultSets();</span><br><span class="line">  <span class="keyword">if</span> (resultSets != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">      ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">      <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String nestedResultMapId = parentMapping.getNestedResultMapId();</span><br><span class="line">        ResultMap resultMap = configuration.getResultMap(nestedResultMapId);</span><br><span class="line">        handleResultSet(rsw, resultMap, <span class="keyword">null</span>, parentMapping);</span><br><span class="line">      &#125;</span><br><span class="line">      rsw = getNextResultSet(stmt);</span><br><span class="line">      cleanUpAfterHandlingResultSet();</span><br><span class="line">      resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是单元素，则取第一个元素返回</span></span><br><span class="line">  <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.apache.ibatis.executor.resultset.DefaultResultSetHandler#handleResultSet</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResultSet</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 存储过程会调用到if中</span></span><br><span class="line">    <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">      handleRowValues(rsw, resultMap, <span class="keyword">null</span>, RowBounds.DEFAULT, parentMapping);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        DefaultResultHandler defaultResultHandler = <span class="keyword">new</span> DefaultResultHandler(objectFactory);</span><br><span class="line">        <span class="comment">// 处理ResultSet 返回每一行的row</span></span><br><span class="line">        handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 处理后的结果添加到multipleResults</span></span><br><span class="line">        multipleResults.add(defaultResultHandler.getResultList());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handleRowValues(rsw, resultMap, resultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeResultSet(rsw.getResultSet());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>mybatis初始化流程</title>
    <url>/2020/10/01/mybatis%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>mybatis 初始化的过程首先需要把配置文件加载成字节数入流，然后把输入流传入<code>org.apache.ibatis.session.SqlSessionFactoryBuilder#build(java.io.InputStream)</code>方法来构造<code>SqlSessionFactory</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 解析xml</span></span><br><span class="line">    XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">    <span class="comment">// 创建SqlSessionFactory parser.parse() 的返回值是Configuration</span></span><br><span class="line">    <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.apache.ibatis.builder.xml.XMLConfigBuilder#parse</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// XMLConfigBuilder只能用一次，判断是否用过</span></span><br><span class="line">  <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 读取xml的顶层标签configuration作为参数传入parseConfiguration</span></span><br><span class="line">  parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">  <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration</code> 具体解析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 解析properties标签</span></span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">    <span class="comment">// 解析settings标签</span></span><br><span class="line">    Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">    <span class="comment">// 加载自定义VFS实现类</span></span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    <span class="comment">// 解析typeAliases标签</span></span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">    <span class="comment">// 解析plugins标签</span></span><br><span class="line">    pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">    <span class="comment">// 解析objectFactory标签</span></span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">    <span class="comment">// 解析objectWrapperFactory标签</span></span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">    <span class="comment">// 解析reflectorFactory标签</span></span><br><span class="line">    reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">    <span class="comment">// 把settings的内容设置到Configuration</span></span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    <span class="comment">// 解析environments标签</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">    <span class="comment">// 解析databaseIdProvider标签</span></span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">    <span class="comment">// 解析typeHandlers标签</span></span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">    <span class="comment">// 解析mappers标签</span></span><br><span class="line">    mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果解析方法之后得到一个<code>Configuration</code>对象</p><p>org.apache.ibatis.session.SqlSessionFactoryBuilder#build(org.apache.ibatis.session.Configuration)<br>构建 DefaultSqlSessionFactory</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 传入 Configuration 对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>mybatis插件</title>
    <url>/2020/10/01/mybatis%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>mybatis 的四大核心对象都提供了插件的扩展机制。对于<strong>mybatis</strong>来说插件就是拦截器。本质是通过动态代理实现的。<br><img src="/images/8c39a064cb78695c040da544c8fee785.svg" alt=""></p><h2 id="插件原理"><a href="#插件原理" class="headerlink" title="插件原理"></a>插件原理</h2><p>每个创建出来的对象不是直接返回的。而是<code>org.apache.ibatis.plugin.InterceptorChain#pluginAll</code>处理后返回的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">    target = interceptor.plugin(target);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>interceptor.plugin</code>返回包装后的对象。</p><p>插件机制。使用插件为目标对象创建一个代理对象。代理对象就可以拦截到四大对象的执行。</p><h2 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h2><p><strong>mybatis</strong>插件需要实现<code>Intercepter</code>接口，该接口有三个方法</p><ul><li><code>intercep</code>插件的核心实现逻辑</li><li><code>plugin</code>前面提到过的生成插件代理的方法</li><li><code>setProperties</code>传递插件所需要的参数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.lmikoto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.statement.StatementHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.plugin.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Intercepts</span>(&#123;</span><br><span class="line">       <span class="meta">@Signature</span>(type = StatementHandler<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">               <span class="title">method</span> </span>= <span class="string">"prepare"</span>,</span><br><span class="line">               args = &#123;Connection<span class="class">.<span class="keyword">class</span>,<span class="title">Integer</span>.<span class="title">class</span>&#125;</span></span><br><span class="line"><span class="class">       )</span></span><br><span class="line"><span class="class">&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MyPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接口增强"</span>);</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"要增强的对象"</span>);</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target,<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"插件的参数"</span> + properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sqlMapConfig.xml</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"io.github.lmikoto.MyPlugin"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Tom"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>mybatis 的插件本质上就是动态代理。<br><code>org.apache.ibatis.plugin.Plugin</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">    <span class="comment">// 判断刚方法是否有拦截</span></span><br><span class="line">    <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">      <span class="comment">// 执行插件的方法</span></span><br><span class="line">      <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行被拦截的方法</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>signatureMap</code>是在调用<code>org.apache.ibatis.plugin.Plugin#wrap</code>初始化的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">  Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">  Class&lt;?&gt; type = target.getClass();</span><br><span class="line">  Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">  <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">        type.getClassLoader(),</span><br><span class="line">        interfaces,</span><br><span class="line">        <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.apache.ibatis.plugin.Plugin#getSignatureMap</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;</span><br><span class="line">  <span class="comment">// 获取拦截器中的Intercepts声明</span></span><br><span class="line">  Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="keyword">if</span> (interceptsAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">"No @Intercepts annotation was found in interceptor "</span> + interceptor.getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取想要拦截的方法</span></span><br><span class="line">  Signature[] sigs = interceptsAnnotation.value();</span><br><span class="line">  Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Signature sig : sigs) &#123;</span><br><span class="line">    Set&lt;Method&gt; methods = signatureMap.get(sig.type());</span><br><span class="line">    <span class="comment">// 没有初始化的话初始化</span></span><br><span class="line">    <span class="keyword">if</span> (methods == <span class="keyword">null</span>) &#123;</span><br><span class="line">      methods = <span class="keyword">new</span> HashSet&lt;Method&gt;();</span><br><span class="line">      signatureMap.put(sig.type(), methods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 用反射从mybatis的类中获取拦截器上声明的方法</span></span><br><span class="line">      Method method = sig.type().getMethod(sig.method(), sig.args());</span><br><span class="line">      methods.add(method);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">"Could not find method on "</span> + sig.type() + <span class="string">" named "</span> + sig.method() + <span class="string">". Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> signatureMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>dubbo实现分布式按需调用指定服务</title>
    <url>/2020/09/29/dubbo%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E6%8C%89%E9%9C%80%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>分布式部署了很多的服务提供者，dubbo 默认会调用到一个提供者，现在要调用到指定的其中一个，或者多个提供者。<br>可以通过实现<code>AbstractClusterInvoker</code>来解决这个问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        checkInvokers(invokers, invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 外部传入需要调用的ip</span></span><br><span class="line">        List&lt;String&gt; ips = (List&lt;String&gt;) RpcContext.getContext().get(<span class="string">"ips"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据ip找到对应的提供者。</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; toInvokers = invokers.stream().filter(invoker -&gt; ips.contains(invoker.getUrl().getHost())).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Result result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Invoker invoker: toInvokers)&#123;</span><br><span class="line">                result = invoker.invoke(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"invoke fail"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Spring Aop实现乐观锁重试</title>
    <url>/2020/09/29/Spring%20Aop%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81%E9%87%8D%E8%AF%95/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><blockquote><p>并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。</p></blockquote><p>阿里巴巴开发手册中指出乐观锁需要至少重试三次，但是我厂的应用好像都没有这个习惯，遇到冲突就直接抛错，这样对于用户来说就会相对不友好一些。<br>那么如何来实现这个乐观锁重试呢。<br>采用 AOP 应该是相对优雅的一种方式。<br>首先定义一个异常类方便精确定位乐观锁更新异常。当然如果使用 jpa 的话，可以直接捕获<code>ObjectOptimisticLockingFailureException</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptimisticLockingFailureException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OptimisticLockingFailureException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个切面。这里切的范围就看实际应用的范围了，以我厂的架构而言，可以直接切所有 RPC 接口的实现。当然也可以精确到切所有 DAO 层的方法。这个看应用场景。为了演示方便，我这里就定义一个注解，用来切这个注解的方法，当然在实际应用中也可以像我这么搞。<br>定义注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TryAgain &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切面实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptimisticLockTryAgainAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;optimistic.lock.retry.num:3&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer maxRetries;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(TryAgain)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retryOnOptFailure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"retryOnOptFailure()"</span>)</span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Object</span> <span class="title">doConcurrentOperation</span>(<span class="title">ProceedingJoinPoint</span> <span class="title">pjp</span>) <span class="title">throws</span> <span class="title">Throwable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> retries = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            retries++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (OptimisticLockingFailureException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (retries &gt; maxRetries) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"update.fail"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    log.warn(<span class="string">"retry &#123;&#125; num"</span>,retries);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (retries &lt;= <span class="keyword">this</span>.maxRetries);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样如果再 update 的时候，如果更新失败就可以抛<code>OptimisticLockingFailureException</code>来做到重试了。</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>mysql数据字典生成</title>
    <url>/2020/09/29/mysql%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目文档中经常需要列出数据库的字典结构。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>mysql 中的 information_schema.tables 记录了表的元信息。information_schema.columns 记录了字段的元信息。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>为了方便使用 python 进行实现。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">host = sys.argv[<span class="number">1</span>]</span><br><span class="line">user = sys.argv[<span class="number">2</span>]</span><br><span class="line">password = sys.argv[<span class="number">3</span>]</span><br><span class="line">schema = sys.argv[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">output = schema + <span class="string">'_dict.md'</span></span><br><span class="line">connection = pymysql.connect(host=host,</span><br><span class="line">                             user=user,</span><br><span class="line">                             password=password,</span><br><span class="line">                             port=<span class="number">3306</span>,</span><br><span class="line">                             db=<span class="string">'information_schema'</span>,</span><br><span class="line">                             charset=<span class="string">'utf8'</span>)</span><br><span class="line">cursor = connection.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">"select table_schema,table_name,table_comment from information_schema.tables where table_schema = '"</span> + schema + <span class="string">"'"</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line"></span><br><span class="line">schemaTableInfoList = cursor.fetchall()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(schemaTableInfoList) == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'no tables'</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">schemaTableInfoDict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(output,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> schemaTableInfoList:</span><br><span class="line">        schemaTableInfoDict.setdefault(item[<span class="number">0</span>], []).append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> schema, tableInfoList <span class="keyword">in</span> schemaTableInfoDict.items():</span><br><span class="line">        <span class="keyword">for</span> tableInfo <span class="keyword">in</span> tableInfoList:</span><br><span class="line">            tableName = tableInfo[<span class="number">1</span>]</span><br><span class="line">            tableComment = tableInfo[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">            tableInfoSql = <span class="string">"select c.column_name as '字段名',"</span> \</span><br><span class="line">                           <span class="string">"c.column_type as '数据类型',"</span> \</span><br><span class="line">                           <span class="string">"c.is_nullable as '允许为空',"</span> \</span><br><span class="line">                           <span class="string">"c.column_comment as '字段说明' FROM information_schema.columns c "</span> \</span><br><span class="line">                           <span class="string">"inner JOIN information_schema.tables t ON c.table_schema = t.table_schema"</span> \</span><br><span class="line">                           <span class="string">" AND c.table_name = t.table_name"</span> \</span><br><span class="line">                           <span class="string">" WHERE t.table_schema = '"</span>+str(schema)+<span class="string">"' and t.table_name='"</span>+str(tableName)+<span class="string">"'"</span></span><br><span class="line">            cursor.execute(tableInfoSql)</span><br><span class="line">            tableColumnInfoList = cursor.fetchall()</span><br><span class="line"></span><br><span class="line">            f.write(<span class="string">'### '</span> + tableName + <span class="string">'('</span> + tableComment + <span class="string">')\n'</span>)</span><br><span class="line">            f.write(<span class="string">'| 字段名 | 数据类型 | 允许为空 | 字段说明 | \n'</span>)</span><br><span class="line">            f.write(<span class="string">'| ---- | ---- | ---- | ---- | \n'</span>)</span><br><span class="line">            <span class="keyword">for</span> tableColumn <span class="keyword">in</span> tableColumnInfoList:</span><br><span class="line">                f.write(<span class="string">'|'</span> + tableColumn[<span class="number">0</span>] + <span class="string">'|'</span> + tableColumn[<span class="number">1</span>] + <span class="string">'|'</span> + tableColumn[<span class="number">2</span>] + <span class="string">'|'</span> + tableColumn[<span class="number">3</span>] + <span class="string">'|\n'</span>)</span><br><span class="line">            f.write(<span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 db_dict.py 127.0.0.1 root 123456 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Activiti7源码分析(七)-DeploymentCache</title>
    <url>/2020/09/29/Activiti7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%83)-DeploymentCache/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>之前提到过流程的定义是放到缓存中的，而默认缓存是在内存中的在多实例部署的情况下会有隐患。今天来看一下这个缓存是如何实现的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeploymentCache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">(String id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(String id, T object)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>activiti 抽象了一个接口。并且提供了一个默认实现。<br>这个默认实现有两个构造函数。<br>先来看一下有参数的这个构造函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultDeploymentCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.cache = synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, T&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用无参构造函数的时候。缓存容器是 HashMap<br>再来看一下有参构造函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultDeploymentCache</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.cache = synchronizedMap(<span class="keyword">new</span> LinkedHashMap&lt;String, T&gt;(limit + <span class="number">1</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>) &#123; <span class="comment">// +1 is needed, because the entry is inserted first, before it is removed</span></span><br><span class="line">        <span class="comment">// 0.75 is the default (see javadocs)</span></span><br><span class="line">        <span class="comment">// true will keep the 'access-order', which is needed to have a real LRU cache</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;String, T&gt; eldest)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">boolean</span> removeEldest = size() &gt; limit;</span><br><span class="line">          <span class="keyword">if</span> (removeEldest &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Cache limit is reached, &#123;&#125; will be evicted"</span>, eldest.getKey());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> removeEldest;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有参构造函数会传入一个 limit,也就是缓存大小。下面的策略说的也很明白，如果超过了这个大小就会最老的给移除掉。<br>如果确定流程定义很少，那么可以用无限制的，如果很多肯定要用有限制的。<br>所以无论有参还是无参，默认的缓存都是在内存里。<br>缓存的读取策略一般都是先从缓存拿，如果没拿到就从 db 拿，然后把缓存更新一下。多实例的情况下缓存不会同步，正常情况下也不会产生太多的问题，只是可能没命中多查了一次 db 而已。而之前提到的用 ProcessDefinitionKey 发起流程是特殊情况，这样的情况下没有同步缓存就会产生事故。<br>所以针对上述问题，个人认为最好还是使用 redis 这种中间键来做缓存。替换也很简单，实现一下 DeploymentCache 接口。然后在配置类中把他替换掉就好了。如果使用 spring 的话，直接替换 bean 即可。</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Activiti7源码分析(六)-发起流程</title>
    <url>/2020/09/29/Activiti7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%85%AD)-%E5%8F%91%E8%B5%B7%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>发起流程是 service 都在 runtimeService 中。Service 的调用链路可以看之前的文章。这里直接从 cmd 开始。<br>发起流程肯定要获取这个流程是怎么定义的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DeploymentManager deploymentCache = commandContext.getProcessEngineConfiguration().getDeploymentManager();</span><br><span class="line"></span><br><span class="line">ProcessDefinitionRetriever processRetriever = <span class="keyword">new</span> ProcessDefinitionRetriever(<span class="keyword">this</span>.tenantId, deploymentCache);</span><br><span class="line">ProcessDefinition processDefinition = processRetriever.getProcessDefinition(<span class="keyword">this</span>.processDefinitionId, <span class="keyword">this</span>.processDefinitionKey);</span><br></pre></td></tr></table></figure><p>看一下 getProcessDefinition 的实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (processDefinitionId == <span class="keyword">null</span> &amp;&amp; processDefinitionKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiIllegalArgumentException(<span class="string">"processDefinitionKey and processDefinitionId are null"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ProcessDefinition processDefinition = <span class="keyword">this</span>.getProcessDefinitionByProcessDefinitionId(processDefinitionId, deploymentCache);</span><br><span class="line">  <span class="keyword">if</span>(processDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">      processDefinition = (processDefinitionKey != <span class="keyword">null</span> &amp;&amp; hasNoTenant(tenantId)) ?</span><br><span class="line">          <span class="keyword">this</span>.getProcessDefinitionByProcessDefinitionKey(processDefinitionKey, deploymentCache):</span><br><span class="line">          <span class="keyword">this</span>.getProcessDefinitionByProcessDefinitionKeyAndTenantId(processDefinitionKey, tenantId, deploymentCache);</span><br><span class="line">      <span class="keyword">if</span> (processDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiObjectNotFoundException(<span class="string">"No process definition found for key '"</span> + processDefinitionKey + <span class="string">"' for tenant identifier "</span> + tenantId, ProcessDefinition<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> processDefinition;</span><br></pre></td></tr></table></figure><p>这里先简单介绍一下 processDefinitionId、processDefinitionKey 吧。processDefinitionId 是流程图的唯一标示。每次修改流程图，新的流程图都会和之前的不一样。而 processDefinitionKey 是创建图的时候会新建一个，而之后修改都不会变动。<br>调用这个 cmd 的方法，有的会把这两个都传过来，有的只会传一个，所以这里会有一些判断。<br>由于 processDefinitionId 是唯一的，所以他这里会先判断有没有 processDefinitionId，如果有的话用 processDefinitionId 从缓存中找流程定义。如果没有的话，再用 processDefinitionKey 从缓存中找。<br>这里其实有点小坑。如果在多实例的情况下，使用默认的缓存机制及内存缓存。如果更新了定义，不同实例的缓存是不会同步的。如果是用 processDefinitionKey 为依据去发起流程的话，可能会由于缓存没同步而造成事故。<br>针对这个坑点，发起实例尽量用 processDefinitionId 来发起，或者使用中间键作为缓存。<br>我们继续。这里会尝试从缓存中拿。如果拿不到就从 db 中拿。代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ProcessDefinition <span class="title">findDeployedProcessDefinitionById</span><span class="params">(String processDefinitionId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (processDefinitionId == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiIllegalArgumentException(<span class="string">"Invalid process definition id : null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first try the cache</span></span><br><span class="line">    ProcessDefinitionCacheEntry cacheEntry = processDefinitionCache.get(processDefinitionId);</span><br><span class="line">    ProcessDefinition processDefinition = cacheEntry != <span class="keyword">null</span> ? cacheEntry.getProcessDefinition() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (processDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">      processDefinition = processDefinitionEntityManager.findById(processDefinitionId);</span><br><span class="line">      <span class="keyword">if</span> (processDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiObjectNotFoundException(<span class="string">"no deployed process definition found with id '"</span> + processDefinitionId + <span class="string">"'"</span>, ProcessDefinition<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      processDefinition = resolveProcessDefinition(processDefinition).getProcessDefinition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processDefinition;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>拿到流程定义之后，发起流程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProcessInstance processInstance = createAndStartProcessInstance(processDefinition, businessKey, processInstanceName, variables, transientVariables);</span><br></pre></td></tr></table></figure><p>点进去这个，然后向下追踪</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ExecutionEntity <span class="title">createProcessInstanceWithInitialFlowElement</span><span class="params">(ProcessDefinition processDefinition,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                       String businessKey,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                       String processInstanceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                       FlowElement initialFlowElement,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                       Process process)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        ExecutionEntity processInstance = commandContext.getExecutionEntityManager()</span><br><span class="line">            .createProcessInstanceExecution(processDefinition,</span><br><span class="line">                businessKey,</span><br><span class="line">                processDefinition.getTenantId(),</span><br><span class="line">                initiatorVariableName);</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> processInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ProcessInstance（流程实例）、Execution（执行实例)。ProcessInstance 是主执行流，继承 Execution。当流程中没有分治的时候这两个概念其实是相等的。在 activiti 中，这种情况下他们的 id 都会相同。而如果流程中存在分支比，那么在分支口会形成子 Execution。<br>这里我们点进去看他的方法。首先进行数据组装。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutionEntity processInstanceExecution = executionDataManager.create();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isExecutionRelatedEntityCountEnabledGlobally()) &#123;</span><br><span class="line">    ((CountingExecutionEntity) processInstanceExecution).setCountEnabled(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processInstanceExecution.setProcessDefinitionId(processDefinition.getId());</span><br><span class="line">processInstanceExecution.setProcessDefinitionKey(processDefinition.getKey());</span><br><span class="line">processInstanceExecution.setProcessDefinitionName(processDefinition.getName());</span><br><span class="line">processInstanceExecution.setProcessDefinitionVersion(processDefinition.getVersion());</span><br><span class="line">processInstanceExecution.setAppVersion(processDefinition.getAppVersion());</span><br><span class="line">processInstanceExecution.setBusinessKey(businessKey);</span><br><span class="line">processInstanceExecution.setScope(<span class="keyword">true</span>); <span class="comment">// process instance is always a scope for all child executions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Inherit tenant id (if any)</span></span><br><span class="line"><span class="keyword">if</span> (tenantId != <span class="keyword">null</span>) &#123;</span><br><span class="line">    processInstanceExecution.setTenantId(tenantId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String authenticatedUserId = Authentication.getAuthenticatedUserId();</span><br><span class="line"></span><br><span class="line">processInstanceExecution.setStartUserId(authenticatedUserId);</span><br></pre></td></tr></table></figure><p>插入数据库,这里可以看到 流程实例执行的时候会抛两个事件，ENTITY_CREATED、ENTITY_INITIALIZED 可以接一下用于定制化需求。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(EntityImpl entity, <span class="keyword">boolean</span> fireCreateEvent)</span> </span>&#123;</span><br><span class="line">    getDataManager().insert(entity);</span><br><span class="line"></span><br><span class="line">    ActivitiEventDispatcher eventDispatcher = getEventDispatcher();</span><br><span class="line">    <span class="keyword">if</span> (fireCreateEvent &amp;&amp; eventDispatcher.isEnabled()) &#123;</span><br><span class="line">      eventDispatcher.dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_CREATED, entity));</span><br><span class="line">      eventDispatcher.dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_INITIALIZED, entity));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里插入的是 ExecutionEntity 对象，他对应的表是 ACT_RU_EXECUTION。然后返回流程实例 id。<br>回到之前</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (startProcessInstance) &#123;</span><br><span class="line">    CommandContext commandContext = Context.getCommandContext();</span><br><span class="line">    startProcessInstance(processInstance, commandContext, variables, initialFlowElement, transientVariables);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果创建流程实例成功。则启动实例。<br>具体的启动实例这里就不展开了。启动实例之后返回流程实例 id，至此流程发布结束。</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Activiti7源码分析(五)-部署流程</title>
    <url>/2020/09/29/Activiti7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%94)-%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>activiti 的部署的相关操作是由 repositoryService 来负责的。我们直接从 repositoryService 里面的 deploy 方法来往下看。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Deployment <span class="title">deploy</span><span class="params">(DeploymentBuilderImpl deploymentBuilder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> commandExecutor.execute(<span class="keyword">new</span> DeployCmd&lt;Deployment&gt;(deploymentBuilder));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用命令执行器执行了 DeployCmd。关于命令行执行期的调用链路和初始化可以看之前的文章来了解，这里就不展开了。<br>直接看命令执行的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DeploymentEntity deployment = deploymentBuilder.getDeployment();</span><br><span class="line"></span><br><span class="line">deployment.setDeploymentTime(commandContext.getProcessEngineConfiguration().getClock().getCurrentTime());</span><br><span class="line"></span><br><span class="line">setProjectReleaseVersion(deployment);</span><br><span class="line">deployment.setVersion(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这里是组装参数，设置部署的事件和版本。<br>然后下面有个重复过滤器的开关判断，如果打开了这个开关，那么如果没有修改 deployment 的内容数据库就不会新增一条记录了。反之，如果没有打开这个开关，每一次 deploy 都会新生成一条记录。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (deploymentBuilder.isDuplicateFilterEnabled()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">deployment.setNew(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the data</span></span><br><span class="line">commandContext.getDeploymentEntityManager().insert(deployment);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (commandContext.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) &#123;</span><br><span class="line">  commandContext.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_CREATED, deployment));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会把要部署的内容插入到数据库中，并且抛一个 ENTITY_CREATED 的事件出来。如果有需要定制的需求，可以接一下这个事件处理一下。<br>继续向下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Deployment settings</span></span><br><span class="line">Map&lt;String, Object&gt; deploymentSettings = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">deploymentSettings.put(DeploymentSettings.IS_BPMN20_XSD_VALIDATION_ENABLED, deploymentBuilder.isBpmn20XsdValidationEnabled());</span><br><span class="line">deploymentSettings.put(DeploymentSettings.IS_PROCESS_VALIDATION_ENABLED, deploymentBuilder.isProcessValidationEnabled());</span><br></pre></td></tr></table></figure><p>这里塞了两个配置进来，这两个配置如果开启就会校验 model 的，项具用到的地方在后面 bpmn 解析的地方会提到。<br>然后会进行真正的部署</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Actually deploy</span></span><br><span class="line">commandContext.getProcessEngineConfiguration().getDeploymentManager().deploy(deployment, deploymentSettings);</span><br></pre></td></tr></table></figure><p>然后进入这个 deploy 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploy</span><span class="params">(DeploymentEntity deployment, Map&lt;String, Object&gt; deploymentSettings)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Deployer deployer : deployers) &#123;</span><br><span class="line">    deployer.deploy(deployment, deploymentSettings);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会遍历 deployers 然后调用 deploy 方法。<br>这个 deploys 是在流程引擎初始化的时候初始化的，activiti 会出初始化一个 BpmnDeployer，当然用户也可以自己定义前置和后置的 deploy</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.deployers == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.deployers = <span class="keyword">new</span> ArrayList&lt;Deployer&gt;();</span><br><span class="line">  <span class="keyword">if</span> (customPreDeployers != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.deployers.addAll(customPreDeployers);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.deployers.addAll(getDefaultDeployers());</span><br><span class="line">  <span class="keyword">if</span> (customPostDeployers != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.deployers.addAll(customPostDeployers);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Collection&lt;? extends Deployer&gt; getDefaultDeployers() &#123;</span><br><span class="line">  List&lt;Deployer&gt; defaultDeployers = <span class="keyword">new</span> ArrayList&lt;Deployer&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bpmnDeployer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    bpmnDeployer = <span class="keyword">new</span> BpmnDeployer();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  initBpmnDeployerDependencies();</span><br><span class="line"></span><br><span class="line">  bpmnDeployer.setIdGenerator(idGenerator);</span><br><span class="line">  bpmnDeployer.setParsedDeploymentBuilderFactory(parsedDeploymentBuilderFactory);</span><br><span class="line">  bpmnDeployer.setBpmnDeploymentHelper(bpmnDeploymentHelper);</span><br><span class="line">  bpmnDeployer.setCachingAndArtifactsManager(cachingAndArtifactsManager);</span><br><span class="line"></span><br><span class="line">  defaultDeployers.add(bpmnDeployer);</span><br><span class="line">  <span class="keyword">return</span> defaultDeployers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到之前的方法，来看一下 BpmnDeployer 的 deploy 方法是如何实现的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The ParsedDeployment represents the deployment, the process definitions, and the BPMN</span></span><br><span class="line"><span class="comment">// resource, parse, and model associated with each process definition.</span></span><br><span class="line">ParsedDeployment parsedDeployment = parsedDeploymentBuilderFactory</span><br><span class="line">        .getBuilderForDeploymentAndSettings(deployment,</span><br><span class="line">                                            deploymentSettings)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>构建 ParsedDeployment，这个对象相当于一个数据转换对象的容器吧，把数据在这里面组装一下，来看下具体的组装流程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ParsedDeployment <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;ProcessDefinitionEntity&gt; processDefinitions = <span class="keyword">new</span> ArrayList&lt;ProcessDefinitionEntity&gt;();</span><br><span class="line">  Map&lt;ProcessDefinitionEntity, BpmnParse&gt; processDefinitionsToBpmnParseMap</span><br><span class="line">    = <span class="keyword">new</span> LinkedHashMap&lt;ProcessDefinitionEntity, BpmnParse&gt;();</span><br><span class="line">  Map&lt;ProcessDefinitionEntity, ResourceEntity&gt; processDefinitionsToResourceMap</span><br><span class="line">    = <span class="keyword">new</span> LinkedHashMap&lt;ProcessDefinitionEntity, ResourceEntity&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ResourceEntity resource : deployment.getResources().values()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBpmnResource(resource.getName())) &#123;</span><br><span class="line">      log.debug(<span class="string">"Processing BPMN resource &#123;&#125;"</span>, resource.getName());</span><br><span class="line">      BpmnParse parse = createBpmnParseFromResource(resource);</span><br><span class="line">      <span class="keyword">for</span> (ProcessDefinitionEntity processDefinition : parse.getProcessDefinitions()) &#123;</span><br><span class="line">        processDefinitions.add(processDefinition);</span><br><span class="line">        processDefinitionsToBpmnParseMap.put(processDefinition, parse);</span><br><span class="line">        processDefinitionsToResourceMap.put(processDefinition, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ParsedDeployment(deployment, processDefinitions,</span><br><span class="line">      processDefinitionsToBpmnParseMap, processDefinitionsToResourceMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面会用把 xml 解析成 BpmnParse 对象，解析过程这里就不讨论了。然后遍历解析之后的 ProcessDefinitions，把他们塞进 map 里面。<br>然后设置流程图的名字、version 等信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setProcessDefinitionDiagramNames(parsedDeployment);</span><br></pre></td></tr></table></figure><p>如果是新的，还会把所有的 processDefinition 存储一份。然后在设置授权信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">persistProcessDefinitionsAndAuthorizations</span><span class="params">(ParsedDeployment parsedDeployment)</span> </span>&#123;</span><br><span class="line">    CommandContext commandContext = Context.getCommandContext();</span><br><span class="line">    ProcessDefinitionEntityManager processDefinitionManager = commandContext.getProcessDefinitionEntityManager();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ProcessDefinitionEntity processDefinition : parsedDeployment.getAllProcessDefinitions()) &#123;</span><br><span class="line">        processDefinitionManager.insert(processDefinition,</span><br><span class="line">                                        <span class="keyword">false</span>);</span><br><span class="line">        bpmnDeploymentHelper.addAuthorizationsForNewProcessDefinition(parsedDeployment.getProcessModelForProcessDefinition(processDefinition),</span><br><span class="line">                                                                      processDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新时间和事件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">updateTimersAndEvents(parsedDeployment,</span><br><span class="line">                      mapOfNewProcessDefinitionToPreviousVersion);</span><br><span class="line">dispatchProcessDefinitionEntityInitializedEvent(parsedDeployment);</span><br></pre></td></tr></table></figure><p>然后更新缓存，这里其实有点小坑。多实例情况下这个缓存如果用默认的内存缓存，会导致别的实例的缓存更新不及时。并且这里如果作死用 processDefinitionKey 发起流程而不是用 processDefinitionId 发起流程的话就会因为缓存问题产生事故。<br>再回到之前</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (deploymentBuilder.getProcessDefinitionsActivationDate() != <span class="keyword">null</span>) &#123;</span><br><span class="line">  scheduleProcessDefinitionActivation(commandContext, deployment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果设置了激活事件，那么他会把要部署的状态设置为 SUSPENDED，也就是先暂停掉。然后在指定的事件把状态调为激活状态 ACTIVE。这里是用 activiti 内部的 job 实现的状态流转。<br>然后发出部署完成事件 ENTITY_INITIALIZED,完成部署。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (commandContext.getProcessEngineConfiguration().getEventDispatcher().isEnabled()) &#123;</span><br><span class="line">  commandContext.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_INITIALIZED, deployment));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Activiti7源码分析(四)-id生成器</title>
    <url>/2020/09/29/Activiti7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)-id%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>activiti 中定义了 id 生成器的接口，并且提供两个实现。当然你也可以自行实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getNextId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下这个接口的两个实现。</p><h3 id="DbIdGenerator"><a href="#DbIdGenerator" class="headerlink" title="DbIdGenerator"></a>DbIdGenerator</h3><p>DbIdGenerator 是 activiti 的 IdGenerator 默认实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getNextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lastId &lt; nextId) &#123;</span><br><span class="line">    getNewBlock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> _nextId = nextId++;</span><br><span class="line">  <span class="keyword">return</span> Long.toString(_nextId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getNewBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  IdBlock idBlock = commandExecutor.execute(commandConfig, <span class="keyword">new</span> GetNextIdBlockCmd(idBlockSize));</span><br><span class="line">  <span class="keyword">this</span>.nextId = idBlock.getNextId();</span><br><span class="line">  <span class="keyword">this</span>.lastId = idBlock.getLastId();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IdBlock <span class="title">execute</span><span class="params">(CommandContext commandContext)</span> </span>&#123;</span><br><span class="line">  PropertyEntity property = (PropertyEntity) commandContext.getPropertyEntityManager().findById(<span class="string">"next.dbid"</span>);</span><br><span class="line">  <span class="keyword">long</span> oldValue = Long.parseLong(property.getValue());</span><br><span class="line">  <span class="keyword">long</span> newValue = oldValue + idBlockSize;</span><br><span class="line">  property.setValue(Long.toString(newValue));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> IdBlock(oldValue, newValue - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码上很容易看出来，这种方案是在 db 里面记录了一个 next.id 的，每次生成 2500 个 id，然后依次发放。<br>不过这里有点小坑。getNextId 上面有 synchronized 关键字。保证了在单机模式下这个方法没有并发问题。但是在分布式环境下。这里有并发问题。可能生成出来的 id 重复。</p><h3 id="StrongUuidGenerator"><a href="#StrongUuidGenerator" class="headerlink" title="StrongUuidGenerator"></a>StrongUuidGenerator</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ensureGeneratorInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (timeBasedGenerator == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (StrongUuidGenerator<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (timeBasedGenerator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        timeBasedGenerator = Generators.timeBasedGenerator(EthernetAddress.fromInterface());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是用 jackson 里面的 uuid 生成方法。而且也把机器环境传入进去了，这种 id 生成策略是不会有上面那个方法的分布式 id 重复问题。</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Activiti7源码分析(三)-流程引擎配置类</title>
    <url>/2020/09/29/Activiti7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)-%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E%E9%85%8D%E7%BD%AE%E7%B1%BB/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>activiti 的配置类是<code>org.activiti.engine.ProcessEngines</code>,本文主要讨论他的默认实现<code>getDefaultProcessEngine</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProcessEngine <span class="title">getProcessEngine</span><span class="params">(String processEngineName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isInitialized()) &#123;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> processEngines.get(processEngineName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，他会传进去一个 default 的字符串。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProcessEngine <span class="title">getProcessEngine</span><span class="params">(String processEngineName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isInitialized()) &#123;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> processEngines.get(processEngineName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果没有初始化，走初始化的逻辑</li><li>返回 processEngines map 中的配配置，processEngineName 就是上面传过来的 default</li></ul><p>然后再来看 init 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">```java</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这个方法是个同步方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isInitialized()) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又判断了一次是否初始化，可能有的人觉得这步判断有些多余，因为进入这个方法之前已经判断过了，但是在并发场景下并不多余，两个请求都没有初始化过流程引擎，同时走到 init 方法，然后其中一个先执行，另一个等待。一个执行完毕之后，另一个进来，发现已经初始化完成了，就不需要再执行了。<br>然后，获取 activiti 的配置文件 activiti.cfg，进行初始化,代码如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader classLoader = ReflectUtil.getClassLoader();</span><br><span class="line">Enumeration&lt;URL&gt; resources = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  resources = classLoader.getResources(<span class="string">"activiti.cfg.xml"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiIllegalArgumentException(<span class="string">"problem retrieving activiti.cfg.xml resources on the classpath: "</span> + System.getProperty(<span class="string">"java.class.path"</span>), e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove duplicated configuration URL's using set. Some</span></span><br><span class="line"><span class="comment">// classloaders may return identical URL's twice, causing duplicate</span></span><br><span class="line"><span class="comment">// startups</span></span><br><span class="line">Set&lt;URL&gt; configUrls = <span class="keyword">new</span> HashSet&lt;URL&gt;();</span><br><span class="line"><span class="keyword">while</span> (resources.hasMoreElements()) &#123;</span><br><span class="line">  configUrls.add(resources.nextElement());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;URL&gt; iterator = configUrls.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">  URL resource = iterator.next();</span><br><span class="line">  log.info(<span class="string">"Initializing process engine using configuration '&#123;&#125;'"</span>, resource.toString());</span><br><span class="line">  initProcessEngineFromResource(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先去获取了一个 ClassLoader，这个 ClassLoader 可以使用默认自带的，也可以使用自定制的。都没问题。然后获取一下配置文件的的位置。对这些位置去重。然后遍历这些 url，进行初始化资源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProcessEngineInfo processEngineInfo = processEngineInfosByResourceUrl.get(resourceUrl.toString());</span><br><span class="line"><span class="comment">// if there is an existing process engine info</span></span><br><span class="line"><span class="keyword">if</span> (processEngineInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// remove that process engine from the member fields</span></span><br><span class="line">  processEngineInfos.remove(processEngineInfo);</span><br><span class="line">  <span class="keyword">if</span> (processEngineInfo.getException() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    String processEngineName = processEngineInfo.getName();</span><br><span class="line">    processEngines.remove(processEngineName);</span><br><span class="line">    processEngineInfosByName.remove(processEngineName);</span><br><span class="line">  &#125;</span><br><span class="line">  processEngineInfosByResourceUrl.remove(processEngineInfo.getResourceUrl());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里上来也做了个一个类似去重的操作，因为初始化的过程中可能会失败，会走如 retry 方法，这里保证每一个 url 对应的配置信息只有最后加载的那一个。<br>再来看一下构建流程引擎的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessEngine <span class="title">buildProcessEngine</span><span class="params">(URL resource)</span> </span>&#123;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      inputStream = resource.openStream();</span><br><span class="line">      ProcessEngineConfiguration processEngineConfiguration = ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream);</span><br><span class="line">      <span class="keyword">return</span> processEngineConfiguration.buildProcessEngine();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiIllegalArgumentException(<span class="string">"couldn't open resource stream: "</span> + e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      IoUtil.closeSilently(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 url 构建 输入流。然后传入 createProcessEngineConfigurationFromInputStream 方法。再来看一下这个方法,然后依次往下找。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProcessEngineConfiguration <span class="title">parseProcessEngineConfiguration</span><span class="params">(Resource springResource, String beanName)</span> </span>&#123;</span><br><span class="line">    DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">    xmlBeanDefinitionReader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_XSD);</span><br><span class="line">    xmlBeanDefinitionReader.loadBeanDefinitions(springResource);</span><br><span class="line">    ProcessEngineConfigurationImpl processEngineConfiguration = (ProcessEngineConfigurationImpl) beanFactory.getBean(beanName);</span><br><span class="line">    processEngineConfiguration.setBeans(<span class="keyword">new</span> SpringBeanFactoryProxyMap(beanFactory));</span><br><span class="line">    <span class="keyword">return</span> processEngineConfiguration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 beanname 是 processEngineConfiguration，这里省略了中间步骤。<br>这里是使用了 spring 的方法，把 xml 的配置转换成 bean。<br>然后回到 buildProcessEngine</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ProcessEngine <span class="title">buildProcessEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  init();</span><br><span class="line">  ProcessEngineImpl processEngine = <span class="keyword">new</span> ProcessEngineImpl(<span class="keyword">this</span>);</span><br><span class="line">  postProcessEngineInitialisation();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> processEngine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也很好懂。<br>调用 init 方法，这个 init 方法就是上一篇中的那个 init。在这里初始化了 activiti 的资源，包括上篇提到的命令执行器，和职责链，各种 service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">initConfigurators();</span><br><span class="line">configuratorsBeforeInit();</span><br><span class="line">initHistoryLevel();</span><br><span class="line">initExpressionManager();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (usingRelationalDatabase) &#123;</span><br><span class="line">  initDataSource();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initAgendaFactory();</span><br><span class="line">initHelpers();</span><br><span class="line">initVariableTypes();</span><br><span class="line">initBeans();</span><br><span class="line">initScriptingEngines();</span><br><span class="line">initClock();</span><br><span class="line">initBusinessCalendarManager();</span><br><span class="line">initCommandContextFactory();</span><br><span class="line">initTransactionContextFactory();</span><br><span class="line">initCommandExecutors();</span><br><span class="line">initServices();</span><br><span class="line">initIdGenerator();</span><br><span class="line">initBehaviorFactory();</span><br><span class="line">initListenerFactory();</span><br><span class="line">initBpmnParser();</span><br><span class="line">initProcessDefinitionCache();</span><br><span class="line">initProcessDefinitionInfoCache();</span><br><span class="line">initKnowledgeBaseCache();</span><br><span class="line">initJobHandlers();</span><br><span class="line">initJobManager();</span><br><span class="line">initAsyncExecutor();</span><br><span class="line"></span><br><span class="line">initTransactionFactory();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (usingRelationalDatabase) &#123;</span><br><span class="line">  initSqlSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initSessionFactories();</span><br><span class="line">initDataManagers();</span><br><span class="line">initEntityManagers();</span><br><span class="line">initHistoryManager();</span><br><span class="line">initJpa();</span><br><span class="line">initDeployers();</span><br><span class="line">initDelegateInterceptor();</span><br><span class="line">initEventHandlers();</span><br><span class="line">initFailedJobCommandFactory();</span><br><span class="line">initEventDispatcher();</span><br><span class="line">initProcessValidator();</span><br><span class="line">initDatabaseEventLogging();</span><br><span class="line">configuratorsAfterInit();</span><br></pre></td></tr></table></figure><p>里面一些比较重要的，后面会进行讨论，这里就不进行展开了。<br>回到之前方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  resources = classLoader.getResources(<span class="string">"activiti-context.xml"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiIllegalArgumentException(<span class="string">"problem retrieving activiti-context.xml resources on the classpath: "</span> + System.getProperty(<span class="string">"java.class.path"</span>), e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (resources.hasMoreElements()) &#123;</span><br><span class="line">  URL resource = resources.nextElement();</span><br><span class="line">  log.info(<span class="string">"Initializing process engine using Spring configuration '&#123;&#125;'"</span>, resource.toString());</span><br><span class="line">  initProcessEngineFromSpringResource(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>activiti 也支持 Spring 风格的初始化。这里获取了 activiti-context.xml，然后调用 initProcessEngineFromSpringResource 初始化资源。<br>来看一下 initProcessEngineFromSpringResource</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; springConfigurationHelperClass = ReflectUtil.loadClass(<span class="string">"org.activiti.spring.SpringConfigurationHelper"</span>);</span><br><span class="line">    Method method = springConfigurationHelperClass.getDeclaredMethod(<span class="string">"buildProcessEngine"</span>, <span class="keyword">new</span> Class&lt;?&gt;[] &#123; URL<span class="class">.<span class="keyword">class</span> &#125;)</span>;</span><br><span class="line">    ProcessEngine processEngine = (ProcessEngine) method.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; resource &#125;);</span><br><span class="line"></span><br><span class="line">    String processEngineName = processEngine.getName();</span><br><span class="line">    ProcessEngineInfo processEngineInfo = <span class="keyword">new</span> ProcessEngineInfoImpl(processEngineName, resource.toString(), <span class="keyword">null</span>);</span><br><span class="line">    processEngineInfosByName.put(processEngineName, processEngineInfo);</span><br><span class="line">    processEngineInfosByResourceUrl.put(resource.toString(), processEngineInfo);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiException(<span class="string">"couldn't initialize process engine from spring configuration resource "</span> + resource.toString() + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过反射调用 SpringConfigurationHelper 的 buildProcessEngine 方法。来看一下这个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProcessEngine <span class="title">buildProcessEngine</span><span class="params">(URL resource)</span> </span>&#123;</span><br><span class="line">  log.debug(<span class="string">"==== BUILDING SPRING APPLICATION CONTEXT AND PROCESS ENGINE ========================================="</span>);</span><br><span class="line"></span><br><span class="line">  ApplicationContext applicationContext = <span class="keyword">new</span> GenericXmlApplicationContext(<span class="keyword">new</span> UrlResource(resource));</span><br><span class="line">  Map&lt;String, ProcessEngine&gt; beansOfType = applicationContext.getBeansOfType(ProcessEngine<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="keyword">if</span> ((beansOfType == <span class="keyword">null</span>) || (beansOfType.isEmpty())) &#123;</span><br><span class="line">    throw new ActivitiException("no " + ProcessEngine.class.getName() + " defined in the application context " + resource.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ProcessEngine processEngine = beansOfType.values().iterator().next();</span><br><span class="line"></span><br><span class="line">  log.debug(<span class="string">"==== SPRING PROCESS ENGINE CREATED =================================================================="</span>);</span><br><span class="line">  <span class="keyword">return</span> processEngine;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>好的。activiti 的配置类分析到此就结束了。<br>简单总结一下，activiti 配置类主要的工作就是做一些配置的初始化工作，支持 activiti 风格的配置和 spring 风格的配置。</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Activiti7源码分析(二)-Service调用链路</title>
    <url>/2020/09/29/Activiti7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)-Service%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Activiti 采用命令和指责链作为基础的开发模式。各 Service 中定义的方法都有相对应的命令对象 Cmd。Service 把各种请求委托给 Cmd。而一个 Cmd 执行的过程中需要进行一些外围的处理，这些处理过程是一个职责链。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>从流程引擎的配置实现类<code>ProcessEngineConfigurationImpl</code>为入口进入。init 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  initCommandExecutors();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initCommandExecutors</code>中会出事一些配置，比较重要的是最后两个。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initCommandExecutors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  initDefaultCommandConfig();</span><br><span class="line">  initSchemaCommandConfig();</span><br><span class="line">  initCommandInvoker();</span><br><span class="line">  <span class="comment">// 初始化命令拦截器</span></span><br><span class="line">  initCommandInterceptors();</span><br><span class="line">  <span class="comment">// 初始化命令执行器</span></span><br><span class="line">  initCommandExecutor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先来看<code>initCommandInterceptors</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initCommandInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (commandInterceptors == <span class="keyword">null</span>) &#123;</span><br><span class="line">    commandInterceptors = <span class="keyword">new</span> ArrayList&lt;CommandInterceptor&gt;();</span><br><span class="line">    <span class="keyword">if</span> (customPreCommandInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">      commandInterceptors.addAll(customPreCommandInterceptors);</span><br><span class="line">    &#125;</span><br><span class="line">    commandInterceptors.addAll(getDefaultCommandInterceptors());</span><br><span class="line">    <span class="keyword">if</span> (customPostCommandInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">      commandInterceptors.addAll(customPostCommandInterceptors);</span><br><span class="line">    &#125;</span><br><span class="line">    commandInterceptors.add(commandInvoker);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个方法主要做了四个事情。</p><ol><li>如果定制了前置拦截器则加入。</li><li>添加 activiti 默认的拦截器。</li><li>如果定制后置拦截器则加入。</li><li>把命令执行期添加在链条的最后一环。</li></ol><p>来看一下 Activiti 的默认拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Collection&lt;? extends CommandInterceptor&gt; getDefaultCommandInterceptors() &#123;</span><br><span class="line">  List&lt;CommandInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;CommandInterceptor&gt;();</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> LogInterceptor());</span><br><span class="line"></span><br><span class="line">  CommandInterceptor transactionInterceptor = createTransactionInterceptor();</span><br><span class="line">  <span class="keyword">if</span> (transactionInterceptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    interceptors.add(transactionInterceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (commandContextFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CommandContextInterceptor(commandContextFactory, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (transactionContextFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> TransactionContextInterceptor(transactionContextFactory));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> interceptors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>activiti 默认添加三个拦截器及 日志拦截器、commandContext 拦截器、事物拦截器。<br>再来看<code>initCommandExecutor</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initCommandExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (commandExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    CommandInterceptor first = initInterceptorChain(commandInterceptors);</span><br><span class="line">    commandExecutor = <span class="keyword">new</span> CommandExecutorImpl(getDefaultCommandConfig(), first);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法把之间的所有链的节点穿起来。形成了一个职责链,首节点为<code>first</code>。<br>然后初始化了<code>commandExecutor</code><br>那么这个执行器是如何初始化到 service 里</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initService</span><span class="params">(Object service)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (service <span class="keyword">instanceof</span> ServiceImpl) &#123;</span><br><span class="line">    ((ServiceImpl) service).setCommandExecutor(commandExecutor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Service-调用"><a href="#Service-调用" class="headerlink" title="Service 调用"></a>Service 调用</h2><p>下面就来说一下 Service 调用。<br>以删除任务的<code>deleteTask</code>为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteTask</span><span class="params">(String taskId, String deleteReason)</span> </span>&#123;</span><br><span class="line">  commandExecutor.execute(<span class="keyword">new</span> DeleteTaskCmd(taskId, deleteReason, <span class="keyword">false</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用命令执行期执行 Cmd。<br>看下命令执行器内部的实现，其实就是调用了职责链去执行这个 Cmd，代码如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(Command&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> execute(defaultConfig, command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(CommandConfig config, Command&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first.execute(config, command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文我们说了，整个拦截器职责链的最后一环是<code>commandInvoker</code>,那么来看一下这个的实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(<span class="keyword">final</span> CommandConfig config, <span class="keyword">final</span> Command&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> CommandContext commandContext = Context.getCommandContext();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Execute the command.</span></span><br><span class="line">  <span class="comment">// This will produce operations that will be put on the agenda.</span></span><br><span class="line">  commandContext.getAgenda().planOperation(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      commandContext.setResult(command.execute(commandContext));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run loop for agenda</span></span><br><span class="line">  executeOperations(commandContext);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// At the end, call the execution tree change listeners.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> optimization: only do this when the tree has actually changed (ie check dbSqlSession).</span></span><br><span class="line">  <span class="keyword">if</span> (commandContext.hasInvolvedExecutions()) &#123;</span><br><span class="line">    Context.getAgenda().planExecuteInactiveBehaviorsOperation();</span><br><span class="line">    executeOperations(commandContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (T) commandContext.getResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说实际上是在 commandInvoker 中调用 Cmd 的 execute 方法来执行的操作。<br>再来看一下 Cmd 中的 execute</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Void <span class="title">execute</span><span class="params">(CommandContext commandContext)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (taskId != <span class="keyword">null</span>) &#123;</span><br><span class="line">    deleteTask(commandContext, taskId);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (taskIds != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String taskId : taskIds) &#123;</span><br><span class="line">      deleteTask(commandContext, taskId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ActivitiIllegalArgumentException(<span class="string">"taskId and taskIds are null"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下 deleteTask 的实现，然后依次往里面找。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteTask</span><span class="params">(TaskEntity task, String deleteReason, <span class="keyword">boolean</span> cascade, <span class="keyword">boolean</span> cancel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!task.isDeleted()) &#123;</span><br><span class="line">    getProcessEngineConfiguration().getListenerNotificationHelper()</span><br><span class="line">      .executeTaskListeners(task, TaskListener.EVENTNAME_DELETE);</span><br><span class="line">    task.setDeleted(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    String taskId = task.getId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除子任务</span></span><br><span class="line">    List&lt;Task&gt; subTasks = findTasksByParentTaskId(taskId);</span><br><span class="line">    <span class="keyword">for</span> (Task subTask : subTasks) &#123;</span><br><span class="line">      deleteTask((TaskEntity) subTask, deleteReason, cascade, cancel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除标示和变量</span></span><br><span class="line">    getIdentityLinkEntityManager().deleteIdentityLinksByTaskId(taskId);</span><br><span class="line">    getVariableInstanceEntityManager().deleteVariableInstanceByTask(task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按需清理历史表</span></span><br><span class="line">    <span class="keyword">if</span> (cascade) &#123;</span><br><span class="line">      getHistoricTaskInstanceEntityManager().delete(taskId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      getHistoryManager().recordTaskEnd(taskId, deleteReason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete(task, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送删除事件</span></span><br><span class="line">    <span class="keyword">if</span> (getEventDispatcher().isEnabled()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cancel &amp;&amp; !task.isCanceled()) &#123;</span><br><span class="line">        task.setCanceled(<span class="keyword">true</span>);</span><br><span class="line">                getEventDispatcher().dispatchEvent(</span><br><span class="line">                        ActivitiEventBuilder.createActivityCancelledEvent(task.getExecution() != <span class="keyword">null</span> ? task.getExecution().getActivityId() : <span class="keyword">null</span>,</span><br><span class="line">                                task.getName(),</span><br><span class="line">                                <span class="comment">//temporary fix for standalone tasks</span></span><br><span class="line">                                task.getExecutionId() != <span class="keyword">null</span> ? task.getExecutionId() : task.getId(),</span><br><span class="line">                                task.getProcessInstanceId(),</span><br><span class="line">                                task.getProcessDefinitionId(),</span><br><span class="line">                                <span class="string">"userTask"</span>,</span><br><span class="line">                                deleteReason));</span><br><span class="line">      &#125;</span><br><span class="line">      getEventDispatcher().dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.ENTITY_DELETED, task));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法里面其实还是做了很多事情的。包括 activiti 的分表机制，和事件机制。这些机制后面的文章再讨论。<br>再往下找就是 mybatis 层了。至此从 activiti 的 service 层到 db 层的调用链路分析完毕了。从整体层面上来看，activiti 的这种架构方式十分有利于代码的可读性，还是十分有学习的意义。</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Activiti7源码分析(一)-获取源码</title>
    <url>/2020/09/29/Activiti7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)-%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>首先从 github 上面下载源码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git@github.com:Activiti/Activiti.git</span><br></pre></td></tr></table></figure><p>切换到要分析的 tag</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch my v7.1.224</span><br></pre></td></tr></table></figure><p>来简单的看一下 activiti 的项目结构<br><img src="/images/1601388229950-3c381d63-239a-4fed-8771-56d2b23d855a.png" alt="55c83a90-df34-49d2-9dbc-e7fdbcdfe676.png"></p><ul><li>activiti-api 接口定义</li><li>activiti-core 流程引擎核心实现</li><li>activiti-core-common 流程引擎公共服务</li><li>activiti-dependencies 该模块管理 activiti 的依赖关系</li><li>activiti-dependency-check 内置 build-helper-maven-plugin 插件负责在安装或部署 artifact 的时候，附加的安装或部署一些其他资源或文件</li><li>activiti-examples 该模块中有 activiti 的一些例子</li></ul><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>终于解决了吃饭问题</title>
    <url>/2020/09/29/%E7%BB%88%E4%BA%8E%E8%A7%A3%E5%86%B3%E4%BA%86%E5%90%83%E9%A5%AD%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>每次到吃 🍚 的点都会纠结到底吃啥，食堂那么多窗口，今天吃哪一个。<br>终于下定决心写个程序来帮我选择了。<br>首先分析一下需求</p><ul><li>选择食堂的哪个窗口吃饭。最好带上权重，比如我更喜欢吃烧腊而不喜欢小笼包。但是偶尔想吃小笼包换换口味。这样可以把小笼包权重设低一点。</li><li>这个程序最好不是只为吃饭服务。别的其他有选择障碍的东西也可以用这个程序来选择。</li><li>最好可以带上存储功能，我关掉之后下次打开东西还在。</li></ul><p>这些需求一个网页就可以解决掉了。存储功能使用 localStorage 也足够用了。<br>接下来就是实现。<br>技术栈采用 react + antd，加权随机采用扩展集合，使每一项出现的次数与其权重正相关，用均匀随机算法来从中选取的算法来解决，虽然这个算法耗费空间，但是对于这个场景来说足够了。<br>界面<br><img src="/images/1601387936578-a7085974-d3c6-4d49-ae4d-9d900255595a.png" alt="b3be7661-7877-4957-9fff-9ccf9c94ebbb.png"><br><img src="/images/1601387946304-ffcfc369-bc2b-4f6d-af6d-d6a797c63612.png" alt="1562d972-4598-41ee-8a5d-8160a960fe69.png"><br><a href="https://select.lmikoto.com/" target="_blank" rel="noopener">项目访问链接</a><br><a href="https://github.com/lmikoto/select" target="_blank" rel="noopener">源代码</a></p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>使用Notion做博客的后台</title>
    <url>/2020/09/29/%E4%BD%BF%E7%94%A8Notion%E5%81%9A%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%90%8E%E5%8F%B0/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>我又又又开始折腾博客了。<br>最近发现了一个很舒服的工具<a href="https://www.notion.so/" target="_blank" rel="noopener">notion</a>。不但可以记笔记其功能还涵盖了项目管理、wiki、文档等。最主要的是极致的 markdown 书写体验，让我爱不释手。</p><h2 id="博客现状"><a href="#博客现状" class="headerlink" title="博客现状"></a>博客现状</h2><p>先说一下我改造前的博客现状。<br>博客是基于 hexo 搭建的，使用 travis 部署在 github page 上的静态博客。具体可以参考<a href="https://lmikoto.com/2020/05/07/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/" target="_blank" rel="noopener">关于本站</a>。平时写博客的时候需要先<code>hexo new post</code>，然后在 vscode 中写，然后 push 到 github 上。由 travis 帮忙构建和发布。<br>这里的短板算是 vscode 了。因为他并不支持所见即所得编辑。对图片的插入也不是很友好，虽然有插件进行支持。</p><h2 id="改造点"><a href="#改造点" class="headerlink" title="改造点"></a>改造点</h2><p>把写博客的工具由 vscode 迁移到 notion 上来。</p><h2 id="难点以及解决"><a href="#难点以及解决" class="headerlink" title="难点以及解决"></a>难点以及解决</h2><ul><li>notion 到现在还不支持开放 api。对于这个还算好说，虽然不支持开发 api，但是可以直接访问他自己前端用的 api。对于 notion 中公开的文章，访问 api 甚至不用鉴权。</li><li>数据结构不一致。虽然 notion 提供了极致的 mardown 书写体验。但他的数据结构并不是 markdown，而是 notion 自己的 block。要做到这一点，就需要建立一个从 block 到 mardown 的映射。好在不是很困难，找了一些资料然后写了一些代码来解决了这个问题。</li><li>触发构建。原来是 git 提交触发。现在就只能点 travis 的构建按钮进行触发。</li></ul><p>完整的代码放到了<a href="https://github.com/lmikoto/blog/tree/master/notion" target="_blank" rel="noopener">这里了</a>，代码组织的有点烂，如果有想参考这个来做的小伙伴，多见谅哈。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/sorcererxw/notionblog" target="_blank" rel="noopener">https://github.com/sorcererxw/notionblog</a></li></ul><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>使用语雀webhook发布到博客</title>
    <url>/2020/09/29/%E4%BD%BF%E7%94%A8%E8%AF%AD%E9%9B%80webhook%E5%8F%91%E5%B8%83%E5%88%B0%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>整体的部署流程为:<br>在语雀发布文章 -&gt; 触发语雀 webhook -&gt; server 接收到文章推送 -&gt; 请求信息中抽取文章内容和必要信息 -&gt; 调用 GitHub api 更新仓库 -&gt; netlify 自动部署 -&gt; 文章在博客发布<br>本文主要描述 server 的实现过程。</p><h3 id="接收-webhook-的推送"><a href="#接收-webhook-的推送" class="headerlink" title="接收 webhook 的推送"></a>接收 webhook 的推送</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebHookController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/yuque/webhook"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">webHook</span><span class="params">(@RequestBody Object req)</span></span>&#123;</span><br><span class="line">        log.info(JacksonUtils.toJson(req));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清洗语雀内容"><a href="#清洗语雀内容" class="headerlink" title="清洗语雀内容"></a>清洗语雀内容</h3><p>因为语雀会在<code>markdown</code>中添加一些标签，所有需要清洗掉</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">cleanContent</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">    content = content</span><br><span class="line">        .replaceAll(<span class="string">"&lt;br \\/&gt;"</span>,<span class="string">"\n"</span>)</span><br><span class="line">        .replaceAll(<span class="string">"&lt;a name=\".*\"&gt;&lt;/a&gt;"</span>,<span class="string">""</span>);</span><br><span class="line">    log.info(<span class="string">"清洗结束 &#123;&#125;"</span>,content);</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图片替换"><a href="#图片替换" class="headerlink" title="图片替换"></a>图片替换</h3><p>虽然语雀现在的图床在外部系统也可以引用，但是保险起见还是把图片下载下来自己存储。<br>使用正则表达式把图片获取出来，然后调用<code>github api</code>把图片上传到指定目录，然后把文章中的图片替换成新的路径。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadToGitHub</span><span class="params">(String title,String originContent)</span></span>&#123;</span><br><span class="line">    String content = cleanContent(originContent);</span><br><span class="line">    GitHubApi gitHubApi = GitHubApi.getInstance(owner,repo,token);</span><br><span class="line">    RefDto refDto = gitHubApi.getRef();</span><br><span class="line">    CommitDto commitDto = gitHubApi.getCommit(refDto.getObject().getSha());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取图片单独上传</span></span><br><span class="line">    Pattern pattern = Pattern.compile(<span class="string">"!\\[image.png]\\((.*?)\\)"</span>);</span><br><span class="line">    Matcher matcher = pattern.matcher(content);</span><br><span class="line">    List&lt;BlobListDto&gt; blobListDtoArrayList = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String imageUrl = matcher.group(i);</span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(imageUrl);</span><br><span class="line">            String path = uri.getPath();</span><br><span class="line">            String imageName = path.substring(path.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>);</span><br><span class="line">            String githubPath = <span class="string">"/assets/"</span> + imageName;</span><br><span class="line">            content = content.replace(imageUrl,githubPath);</span><br><span class="line">            CreateBlobResponse createBlobResponse = gitHubApi.createBlob(Base64Utils.getImageStrFromUrl(imageUrl),<span class="string">"base64"</span>);</span><br><span class="line">            blobListDtoArrayList.add(<span class="keyword">new</span> BlobListDto(createBlobResponse.getSha(),githubPath));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">"&#123;&#125;"</span>, Throwables.getStackTraceAsString(e));</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    CreateBlobResponse createBlobResponse = gitHubApi.createBlob(content,<span class="string">"utf-8"</span>);</span><br><span class="line">    blobListDtoArrayList.add(<span class="keyword">new</span> BlobListDto(createBlobResponse.getSha(),<span class="string">"content/blog/"</span> + title  + <span class="string">".md"</span>));</span><br><span class="line">    List&lt;Map&lt;String,Object&gt;&gt; treeMpas = Lists.newArrayList();</span><br><span class="line">    blobListDtoArrayList.forEach(i-&gt;&#123;</span><br><span class="line">        treeMpas.add(ImmutableMap.of(<span class="string">"path"</span>,i.getPath(),<span class="string">"mode"</span>,<span class="string">"100644"</span>,<span class="string">"type"</span>,<span class="string">"blob"</span>,<span class="string">"sha"</span>,i.getSha()));</span><br><span class="line">    &#125;);</span><br><span class="line">    CreateTreeResponse createTreeResponse = gitHubApi.createTree(commitDto.getTree().getSha(),treeMpas);</span><br><span class="line">    CreateCommitResponse createCommitResponse = gitHubApi.createCommit(refDto.getObject().getSha(),createTreeResponse.getSha());</span><br><span class="line">    gitHubApi.updataRef(createCommitResponse.getSha());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/lmikoto/yuque-webhook" target="_blank" rel="noopener">完整代码</a></p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>JDBC问题分析及解决思路</title>
    <url>/2020/09/29/JDBC%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载数据库驱动</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">// 通过驱动管理类获取数据库链接</span></span><br><span class="line">connection = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/mybatis? characterEncoding=utf-8"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br></pre></td></tr></table></figure><p>问题</p><ul><li>数据库配置信息存在硬编码问题，如果需要改动需要修改代码，重新打包部署</li><li>频繁的去创建和释放数据库链接，浪费资源</li></ul><p>解决思路</p><ul><li>可以采用配置文件解决硬编码的问题。</li><li>采用连接池解决拼房创建数据库连接的问题</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义sql语句?表示占位符</span></span><br><span class="line">String sql = <span class="string">"select * from user where username = ?"</span>;</span><br><span class="line"><span class="comment">// 获取预处理statement</span></span><br><span class="line">preparedStatement = connection.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 设置参数，第一个参数为sql语句中参数的序号(从1开始)，第二个参数为设置的参数值</span></span><br><span class="line">preparedStatement.setString(<span class="number">1</span>, <span class="string">"tom"</span>);</span><br><span class="line"><span class="comment">// 向数据库发出sql执行查询，查询出结果集</span></span><br><span class="line">resultSet = preparedStatement.executeQuery();</span><br></pre></td></tr></table></figure><p>问题</p><ul><li>sql 语句，设置参数存在硬编码</li></ul><p>解决思路</p><ul><li>配置文件解决，把 sql 封装到配置文件中</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">	<span class="keyword">int</span> id = resultSet.getInt(<span class="string">"id"</span>);</span><br><span class="line">	String username = resultSet.getString(<span class="string">"username"</span>);</span><br><span class="line">	user.setId(id);</span><br><span class="line">	user.setUsername(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题</p><ul><li>硬编码，需要手动封装返回结果集，如果这里有很多字段会非常繁琐。</li></ul><p>解决思路</p><ul><li>反射、内省等技术，实现自动映射</li></ul><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>mybatis缓存</title>
    <url>/2020/09/29/mybatis%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<!-- build time:Tue Feb 16 2021 19:58:15 GMT+0800 (China Standard Time) --><p>Mybatis 分为一级缓存和二级缓存</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><ul><li>一级缓存是<code>sqlSession</code>级别。不同的<code>sqlSession</code>之间的缓存区域互不影响。</li><li>默认是开启的。</li><li>缓存的 key 由<code>statementId</code>,<code>params</code>,<code>boundSql</code>,<code>rowBounds</code>组成</li><li>做增删改操作，并且提交事物会刷新一级缓存。</li><li>一级缓存实际是一个 hashmap<code>org.apache.ibatis.cache.impl.PerpetualCache#cache</code>每一个 sqlsession 都有一个引用</li></ul><p><img src="/images/8b136521b28faac6ac81d955e229eaaa.svg" alt=""></p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><ul><li>二级缓存是<code>namespace</code>（<code>mapper</code>）级别。跨<code>sqlSession</code>。连表查询有问题</li><li>二级缓存默认关闭，需要手动开启。</li><li>做增删改操作，并且提交事物会清空二级缓存。</li><li>从二级缓存中获取数据得到的是一个新的对象。和存入对象的地址不同。</li><li>二级缓存是内存中的 map，因此多实例部署下会有问题。</li></ul><!-- rebuild by neat -->]]></content>
  </entry>
</search>
